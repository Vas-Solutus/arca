// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: router.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RouterService_CreateVLAN_FullMethodName        = "/router.RouterService/CreateVLAN"
	RouterService_DeleteVLAN_FullMethodName        = "/router.RouterService/DeleteVLAN"
	RouterService_ConfigureNAT_FullMethodName      = "/router.RouterService/ConfigureNAT"
	RouterService_RemoveNAT_FullMethodName         = "/router.RouterService/RemoveNAT"
	RouterService_ConfigureDNS_FullMethodName      = "/router.RouterService/ConfigureDNS"
	RouterService_AddPortMapping_FullMethodName    = "/router.RouterService/AddPortMapping"
	RouterService_RemovePortMapping_FullMethodName = "/router.RouterService/RemovePortMapping"
	RouterService_ListVLANs_FullMethodName         = "/router.RouterService/ListVLANs"
	RouterService_GetHealth_FullMethodName         = "/router.RouterService/GetHealth"
)

// RouterServiceClient is the client API for RouterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RouterService manages VLAN interfaces and routing on the helper VM
// This service runs in the helper VM and is accessed by Arca daemon via vsock
type RouterServiceClient interface {
	// CreateVLAN creates a VLAN interface on the helper VM
	// Example: Creates eth0.100 for Docker bridge network
	CreateVLAN(ctx context.Context, in *CreateVLANRequest, opts ...grpc.CallOption) (*CreateVLANResponse, error)
	// DeleteVLAN removes a VLAN interface from the helper VM
	DeleteVLAN(ctx context.Context, in *DeleteVLANRequest, opts ...grpc.CallOption) (*DeleteVLANResponse, error)
	// ConfigureNAT configures NAT (MASQUERADE) for a network
	ConfigureNAT(ctx context.Context, in *ConfigureNATRequest, opts ...grpc.CallOption) (*ConfigureNATResponse, error)
	// RemoveNAT removes NAT configuration for a network
	RemoveNAT(ctx context.Context, in *RemoveNATRequest, opts ...grpc.CallOption) (*RemoveNATResponse, error)
	// ConfigureDNS configures dnsmasq for a VLAN network
	ConfigureDNS(ctx context.Context, in *ConfigureDNSRequest, opts ...grpc.CallOption) (*ConfigureDNSResponse, error)
	// AddPortMapping adds a port forwarding rule (DNAT)
	AddPortMapping(ctx context.Context, in *AddPortMappingRequest, opts ...grpc.CallOption) (*AddPortMappingResponse, error)
	// RemovePortMapping removes a port forwarding rule
	RemovePortMapping(ctx context.Context, in *RemovePortMappingRequest, opts ...grpc.CallOption) (*RemovePortMappingResponse, error)
	// ListVLANs lists all VLAN interfaces on the helper VM
	ListVLANs(ctx context.Context, in *ListVLANsRequest, opts ...grpc.CallOption) (*ListVLANsResponse, error)
	// GetHealth returns health status of the router service
	GetHealth(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
}

type routerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRouterServiceClient(cc grpc.ClientConnInterface) RouterServiceClient {
	return &routerServiceClient{cc}
}

func (c *routerServiceClient) CreateVLAN(ctx context.Context, in *CreateVLANRequest, opts ...grpc.CallOption) (*CreateVLANResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVLANResponse)
	err := c.cc.Invoke(ctx, RouterService_CreateVLAN_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) DeleteVLAN(ctx context.Context, in *DeleteVLANRequest, opts ...grpc.CallOption) (*DeleteVLANResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteVLANResponse)
	err := c.cc.Invoke(ctx, RouterService_DeleteVLAN_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) ConfigureNAT(ctx context.Context, in *ConfigureNATRequest, opts ...grpc.CallOption) (*ConfigureNATResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigureNATResponse)
	err := c.cc.Invoke(ctx, RouterService_ConfigureNAT_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) RemoveNAT(ctx context.Context, in *RemoveNATRequest, opts ...grpc.CallOption) (*RemoveNATResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveNATResponse)
	err := c.cc.Invoke(ctx, RouterService_RemoveNAT_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) ConfigureDNS(ctx context.Context, in *ConfigureDNSRequest, opts ...grpc.CallOption) (*ConfigureDNSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigureDNSResponse)
	err := c.cc.Invoke(ctx, RouterService_ConfigureDNS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) AddPortMapping(ctx context.Context, in *AddPortMappingRequest, opts ...grpc.CallOption) (*AddPortMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddPortMappingResponse)
	err := c.cc.Invoke(ctx, RouterService_AddPortMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) RemovePortMapping(ctx context.Context, in *RemovePortMappingRequest, opts ...grpc.CallOption) (*RemovePortMappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemovePortMappingResponse)
	err := c.cc.Invoke(ctx, RouterService_RemovePortMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) ListVLANs(ctx context.Context, in *ListVLANsRequest, opts ...grpc.CallOption) (*ListVLANsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVLANsResponse)
	err := c.cc.Invoke(ctx, RouterService_ListVLANs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerServiceClient) GetHealth(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, RouterService_GetHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouterServiceServer is the server API for RouterService service.
// All implementations must embed UnimplementedRouterServiceServer
// for forward compatibility.
//
// RouterService manages VLAN interfaces and routing on the helper VM
// This service runs in the helper VM and is accessed by Arca daemon via vsock
type RouterServiceServer interface {
	// CreateVLAN creates a VLAN interface on the helper VM
	// Example: Creates eth0.100 for Docker bridge network
	CreateVLAN(context.Context, *CreateVLANRequest) (*CreateVLANResponse, error)
	// DeleteVLAN removes a VLAN interface from the helper VM
	DeleteVLAN(context.Context, *DeleteVLANRequest) (*DeleteVLANResponse, error)
	// ConfigureNAT configures NAT (MASQUERADE) for a network
	ConfigureNAT(context.Context, *ConfigureNATRequest) (*ConfigureNATResponse, error)
	// RemoveNAT removes NAT configuration for a network
	RemoveNAT(context.Context, *RemoveNATRequest) (*RemoveNATResponse, error)
	// ConfigureDNS configures dnsmasq for a VLAN network
	ConfigureDNS(context.Context, *ConfigureDNSRequest) (*ConfigureDNSResponse, error)
	// AddPortMapping adds a port forwarding rule (DNAT)
	AddPortMapping(context.Context, *AddPortMappingRequest) (*AddPortMappingResponse, error)
	// RemovePortMapping removes a port forwarding rule
	RemovePortMapping(context.Context, *RemovePortMappingRequest) (*RemovePortMappingResponse, error)
	// ListVLANs lists all VLAN interfaces on the helper VM
	ListVLANs(context.Context, *ListVLANsRequest) (*ListVLANsResponse, error)
	// GetHealth returns health status of the router service
	GetHealth(context.Context, *HealthRequest) (*HealthResponse, error)
	mustEmbedUnimplementedRouterServiceServer()
}

// UnimplementedRouterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRouterServiceServer struct{}

func (UnimplementedRouterServiceServer) CreateVLAN(context.Context, *CreateVLANRequest) (*CreateVLANResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVLAN not implemented")
}
func (UnimplementedRouterServiceServer) DeleteVLAN(context.Context, *DeleteVLANRequest) (*DeleteVLANResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVLAN not implemented")
}
func (UnimplementedRouterServiceServer) ConfigureNAT(context.Context, *ConfigureNATRequest) (*ConfigureNATResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureNAT not implemented")
}
func (UnimplementedRouterServiceServer) RemoveNAT(context.Context, *RemoveNATRequest) (*RemoveNATResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNAT not implemented")
}
func (UnimplementedRouterServiceServer) ConfigureDNS(context.Context, *ConfigureDNSRequest) (*ConfigureDNSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureDNS not implemented")
}
func (UnimplementedRouterServiceServer) AddPortMapping(context.Context, *AddPortMappingRequest) (*AddPortMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPortMapping not implemented")
}
func (UnimplementedRouterServiceServer) RemovePortMapping(context.Context, *RemovePortMappingRequest) (*RemovePortMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePortMapping not implemented")
}
func (UnimplementedRouterServiceServer) ListVLANs(context.Context, *ListVLANsRequest) (*ListVLANsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVLANs not implemented")
}
func (UnimplementedRouterServiceServer) GetHealth(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedRouterServiceServer) mustEmbedUnimplementedRouterServiceServer() {}
func (UnimplementedRouterServiceServer) testEmbeddedByValue()                       {}

// UnsafeRouterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RouterServiceServer will
// result in compilation errors.
type UnsafeRouterServiceServer interface {
	mustEmbedUnimplementedRouterServiceServer()
}

func RegisterRouterServiceServer(s grpc.ServiceRegistrar, srv RouterServiceServer) {
	// If the following call pancis, it indicates UnimplementedRouterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RouterService_ServiceDesc, srv)
}

func _RouterService_CreateVLAN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVLANRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).CreateVLAN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_CreateVLAN_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).CreateVLAN(ctx, req.(*CreateVLANRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_DeleteVLAN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVLANRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).DeleteVLAN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_DeleteVLAN_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).DeleteVLAN(ctx, req.(*DeleteVLANRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_ConfigureNAT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureNATRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).ConfigureNAT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_ConfigureNAT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).ConfigureNAT(ctx, req.(*ConfigureNATRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_RemoveNAT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveNATRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).RemoveNAT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_RemoveNAT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).RemoveNAT(ctx, req.(*RemoveNATRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_ConfigureDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureDNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).ConfigureDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_ConfigureDNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).ConfigureDNS(ctx, req.(*ConfigureDNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_AddPortMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPortMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).AddPortMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_AddPortMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).AddPortMapping(ctx, req.(*AddPortMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_RemovePortMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePortMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).RemovePortMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_RemovePortMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).RemovePortMapping(ctx, req.(*RemovePortMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_ListVLANs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVLANsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).ListVLANs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_ListVLANs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).ListVLANs(ctx, req.(*ListVLANsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterService_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterServiceServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RouterService_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterServiceServer).GetHealth(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RouterService_ServiceDesc is the grpc.ServiceDesc for RouterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RouterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "router.RouterService",
	HandlerType: (*RouterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVLAN",
			Handler:    _RouterService_CreateVLAN_Handler,
		},
		{
			MethodName: "DeleteVLAN",
			Handler:    _RouterService_DeleteVLAN_Handler,
		},
		{
			MethodName: "ConfigureNAT",
			Handler:    _RouterService_ConfigureNAT_Handler,
		},
		{
			MethodName: "RemoveNAT",
			Handler:    _RouterService_RemoveNAT_Handler,
		},
		{
			MethodName: "ConfigureDNS",
			Handler:    _RouterService_ConfigureDNS_Handler,
		},
		{
			MethodName: "AddPortMapping",
			Handler:    _RouterService_AddPortMapping_Handler,
		},
		{
			MethodName: "RemovePortMapping",
			Handler:    _RouterService_RemovePortMapping_Handler,
		},
		{
			MethodName: "ListVLANs",
			Handler:    _RouterService_ListVLANs_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _RouterService_GetHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}
