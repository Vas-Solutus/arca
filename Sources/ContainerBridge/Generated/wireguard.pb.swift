// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wireguard.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Arca WireGuard Network Service Protocol
// gRPC API for WireGuard-based container networking

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to create a WireGuard hub interface
public struct Arca_Wireguard_V1_CreateHubRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Private key for this container's WireGuard interface
  /// Base64-encoded Curve25519 key (44 chars)
  public var privateKey: String = String()

  /// Listen port for WireGuard (default: 51820)
  public var listenPort: UInt32 = 0

  /// Container's IP address on first network (assigned to wg0)
  public var ipAddress: String = String()

  /// Network CIDR for the first network (e.g., "172.18.0.0/16")
  public var networkCidr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_CreateHubResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Public key for this container (for peer configuration)
  public var publicKey: String = String()

  /// Interface name created (should be "wg0")
  public var interface: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to add a network to the container
public struct Arca_Wireguard_V1_AddNetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID (Docker network ID)
  public var networkID: String = String()

  /// Peer endpoint (hub's vmnet IP address, e.g., "192.168.65.5:51820")
  public var peerEndpoint: String = String()

  /// Peer's public key (Base64-encoded)
  public var peerPublicKey: String = String()

  /// IP address for this container on this network
  public var ipAddress: String = String()

  /// Network CIDR for allowed-ips routing (e.g., "172.19.0.0/16")
  public var networkCidr: String = String()

  /// Gateway IP for this network (for routing)
  public var gateway: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_AddNetworkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Number of networks now configured
  public var totalNetworks: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to remove a network from the container
public struct Arca_Wireguard_V1_RemoveNetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID to remove
  public var networkID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_RemoveNetworkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Number of networks still configured
  public var remainingNetworks: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to update allowed IPs for multi-network routing
/// Called when containers join/leave networks to update routing table
public struct Arca_Wireguard_V1_UpdateAllowedIPsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Complete set of allowed IP ranges for this peer
  /// Each entry is a CIDR (e.g., "172.18.0.0/16", "172.19.0.0/16")
  public var allowedCidrs: [String] = []

  /// Peer public key to update (identifies which peer to configure)
  public var peerPublicKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_UpdateAllowedIPsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Number of CIDR ranges now allowed
  public var totalAllowed: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to delete the WireGuard hub
public struct Arca_Wireguard_V1_DeleteHubRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Force deletion even if there are active networks
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_DeleteHubResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request WireGuard status
public struct Arca_Wireguard_V1_GetStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_GetStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Service version
  public var version: String = String()

  /// Number of networks configured
  public var networkCount: UInt32 = 0

  /// WireGuard interface status
  public var interface: Arca_Wireguard_V1_InterfaceStatus {
    get {return _interface ?? Arca_Wireguard_V1_InterfaceStatus()}
    set {_interface = newValue}
  }
  /// Returns true if `interface` has been explicitly set.
  public var hasInterface: Bool {return self._interface != nil}
  /// Clears the value of `interface`. Subsequent reads from it will return its default value.
  public mutating func clearInterface() {self._interface = nil}

  /// Peer statistics (one per network)
  public var peers: [Arca_Wireguard_V1_PeerStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interface: Arca_Wireguard_V1_InterfaceStatus? = nil
}

public struct Arca_Wireguard_V1_InterfaceStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface name (should be "wg0")
  public var name: String = String()

  /// Public key
  public var publicKey: String = String()

  /// Listen port
  public var listenPort: UInt32 = 0

  /// IP addresses assigned to interface
  public var ipAddresses: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_PeerStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID this peer represents
  public var networkID: String = String()

  /// Peer public key
  public var publicKey: String = String()

  /// Peer endpoint (IP:port)
  public var endpoint: String = String()

  /// Allowed IPs for this peer
  public var allowedIps: [String] = []

  /// Latest handshake timestamp (Unix seconds, 0 if never)
  public var latestHandshake: UInt64 = 0

  /// Transfer statistics
  public var stats: Arca_Wireguard_V1_TransferStats {
    get {return _stats ?? Arca_Wireguard_V1_TransferStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  public var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  public mutating func clearStats() {self._stats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stats: Arca_Wireguard_V1_TransferStats? = nil
}

public struct Arca_Wireguard_V1_TransferStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bytes received from this peer
  public var bytesReceived: UInt64 = 0

  /// Bytes sent to this peer
  public var bytesSent: UInt64 = 0

  /// Persistent keepalive interval (seconds, 0 if disabled)
  public var persistentKeepalive: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "arca.wireguard.v1"

extension Arca_Wireguard_V1_CreateHubRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateHubRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}private_key\0\u{3}listen_port\0\u{3}ip_address\0\u{3}network_cidr\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.privateKey) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.listenPort) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.networkCidr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKey, fieldNumber: 1)
    }
    if self.listenPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.listenPort, fieldNumber: 2)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 3)
    }
    if !self.networkCidr.isEmpty {
      try visitor.visitSingularStringField(value: self.networkCidr, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_CreateHubRequest, rhs: Arca_Wireguard_V1_CreateHubRequest) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.listenPort != rhs.listenPort {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.networkCidr != rhs.networkCidr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_CreateHubResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateHubResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}public_key\0\u{1}interface\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.interface) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.interface.isEmpty {
      try visitor.visitSingularStringField(value: self.interface, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_CreateHubResponse, rhs: Arca_Wireguard_V1_CreateHubResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.interface != rhs.interface {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_AddNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddNetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{3}peer_endpoint\0\u{3}peer_public_key\0\u{3}ip_address\0\u{3}network_cidr\0\u{1}gateway\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerEndpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.peerPublicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.networkCidr) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if !self.peerEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.peerEndpoint, fieldNumber: 2)
    }
    if !self.peerPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.peerPublicKey, fieldNumber: 3)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 4)
    }
    if !self.networkCidr.isEmpty {
      try visitor.visitSingularStringField(value: self.networkCidr, fieldNumber: 5)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_AddNetworkRequest, rhs: Arca_Wireguard_V1_AddNetworkRequest) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.peerEndpoint != rhs.peerEndpoint {return false}
    if lhs.peerPublicKey != rhs.peerPublicKey {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.networkCidr != rhs.networkCidr {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_AddNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddNetworkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}total_networks\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalNetworks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.totalNetworks != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalNetworks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_AddNetworkResponse, rhs: Arca_Wireguard_V1_AddNetworkResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.totalNetworks != rhs.totalNetworks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_RemoveNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveNetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_RemoveNetworkRequest, rhs: Arca_Wireguard_V1_RemoveNetworkRequest) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_RemoveNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveNetworkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}remaining_networks\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.remainingNetworks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.remainingNetworks != 0 {
      try visitor.visitSingularUInt32Field(value: self.remainingNetworks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_RemoveNetworkResponse, rhs: Arca_Wireguard_V1_RemoveNetworkResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.remainingNetworks != rhs.remainingNetworks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_UpdateAllowedIPsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAllowedIPsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}allowed_cidrs\0\u{3}peer_public_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedCidrs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.peerPublicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedCidrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCidrs, fieldNumber: 1)
    }
    if !self.peerPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.peerPublicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_UpdateAllowedIPsRequest, rhs: Arca_Wireguard_V1_UpdateAllowedIPsRequest) -> Bool {
    if lhs.allowedCidrs != rhs.allowedCidrs {return false}
    if lhs.peerPublicKey != rhs.peerPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_UpdateAllowedIPsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAllowedIPsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}total_allowed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalAllowed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.totalAllowed != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalAllowed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_UpdateAllowedIPsResponse, rhs: Arca_Wireguard_V1_UpdateAllowedIPsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.totalAllowed != rhs.totalAllowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_DeleteHubRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteHubRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}force\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_DeleteHubRequest, rhs: Arca_Wireguard_V1_DeleteHubRequest) -> Bool {
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_DeleteHubResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteHubResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_DeleteHubResponse, rhs: Arca_Wireguard_V1_DeleteHubResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_GetStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_GetStatusRequest, rhs: Arca_Wireguard_V1_GetStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_GetStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}network_count\0\u{1}interface\0\u{1}peers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.networkCount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._interface) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.networkCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.networkCount, fieldNumber: 2)
    }
    try { if let v = self._interface {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_GetStatusResponse, rhs: Arca_Wireguard_V1_GetStatusResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.networkCount != rhs.networkCount {return false}
    if lhs._interface != rhs._interface {return false}
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_InterfaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InterfaceStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}public_key\0\u{3}listen_port\0\u{3}ip_addresses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.listenPort) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.ipAddresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 2)
    }
    if self.listenPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.listenPort, fieldNumber: 3)
    }
    if !self.ipAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipAddresses, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_InterfaceStatus, rhs: Arca_Wireguard_V1_InterfaceStatus) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.listenPort != rhs.listenPort {return false}
    if lhs.ipAddresses != rhs.ipAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_PeerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeerStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{3}public_key\0\u{1}endpoint\0\u{3}allowed_ips\0\u{3}latest_handshake\0\u{1}stats\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.allowedIps) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.latestHandshake) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 2)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 3)
    }
    if !self.allowedIps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedIps, fieldNumber: 4)
    }
    if self.latestHandshake != 0 {
      try visitor.visitSingularUInt64Field(value: self.latestHandshake, fieldNumber: 5)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_PeerStatus, rhs: Arca_Wireguard_V1_PeerStatus) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.allowedIps != rhs.allowedIps {return false}
    if lhs.latestHandshake != rhs.latestHandshake {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_TransferStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferStats"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bytes_received\0\u{3}bytes_sent\0\u{3}persistent_keepalive\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bytesReceived) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bytesSent) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.persistentKeepalive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytesReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesReceived, fieldNumber: 1)
    }
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 2)
    }
    if self.persistentKeepalive != 0 {
      try visitor.visitSingularUInt32Field(value: self.persistentKeepalive, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_TransferStats, rhs: Arca_Wireguard_V1_TransferStats) -> Bool {
    if lhs.bytesReceived != rhs.bytesReceived {return false}
    if lhs.bytesSent != rhs.bytesSent {return false}
    if lhs.persistentKeepalive != rhs.persistentKeepalive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
