// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wireguard.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Arca WireGuard Network Service Protocol
// gRPC API for WireGuard-based container networking

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to check service readiness
public struct Arca_Wireguard_V1_ReadyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response indicating service readiness
public struct Arca_Wireguard_V1_ReadyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if service is fully initialized and ready
  public var ready: Bool = false

  /// Service version
  public var version: String = String()

  /// Milliseconds since service started
  public var uptimeMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to add a network to the container
public struct Arca_Wireguard_V1_AddNetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID (Docker network ID)
  public var networkID: String = String()

  /// Network index (0 for first network → wg0/eth0, 1 for second → wg1/eth1, etc.)
  public var networkIndex: UInt32 = 0

  /// Container ID - used to create the network namespace on first AddNetwork call
  public var containerID: String = String()

  /// Private key for this container's WireGuard interface (Base64-encoded Curve25519 key)
  /// Each wgN interface gets its own private key
  public var privateKey: String = String()

  /// Listen port for WireGuard (51820 + network_index)
  public var listenPort: UInt32 = 0

  /// Peer endpoint (peer's vmnet IP address, e.g., "192.168.65.5:51820")
  public var peerEndpoint: String = String()

  /// Peer's public key (Base64-encoded)
  public var peerPublicKey: String = String()

  /// IP address for this container on this network
  public var ipAddress: String = String()

  /// Network CIDR for routing (e.g., "172.18.0.0/16")
  public var networkCidr: String = String()

  /// Gateway IP for this network (e.g., "172.18.0.1")
  public var gateway: String = String()

  /// Host IP address for host.docker.internal DNS resolution (e.g., "192.168.2.100")
  /// This is the macOS host's LAN IP, allowing containers to reach host services
  public var hostIp: String = String()

  /// Extra hosts for DNS resolution (from --add-host flag)
  /// Format: "hostname:ip" (e.g., "myhost:192.168.1.100")
  public var extraHosts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_AddNetworkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Number of networks now configured
  public var totalNetworks: UInt32 = 0

  /// WireGuard interface name created (wg0, wg1, wg2, etc.)
  public var wgInterface: String = String()

  /// Container interface name (eth0, eth1, eth2, etc.)
  public var ethInterface: String = String()

  /// Public key for this interface (for peer configuration)
  public var publicKey: String = String()

  /// Path to the network namespace (e.g., "/var/run/netns/container-xyz")
  /// The container should join this namespace instead of creating a new one
  public var namespacePath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to remove a network from the container
public struct Arca_Wireguard_V1_RemoveNetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID to remove
  public var networkID: String = String()

  /// Network index (0, 1, 2, etc.) - identifies which wgN/ethN to remove
  public var networkIndex: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_RemoveNetworkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Number of networks still configured
  public var remainingNetworks: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request WireGuard status
public struct Arca_Wireguard_V1_GetStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_GetStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Service version
  public var version: String = String()

  /// Number of networks configured
  public var networkCount: UInt32 = 0

  /// WireGuard interface statuses (one per wgN interface)
  public var interfaces: [Arca_Wireguard_V1_InterfaceStatus] = []

  /// Peer statistics (one per peer, grouped by interface)
  public var peers: [Arca_Wireguard_V1_PeerStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_InterfaceStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID this interface represents
  public var networkID: String = String()

  /// Interface name (wg0, wg1, wg2, etc.)
  public var name: String = String()

  /// Public key for this interface
  public var publicKey: String = String()

  /// Listen port
  public var listenPort: UInt32 = 0

  /// IP addresses assigned to interface
  public var ipAddresses: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_PeerStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID this peer represents
  public var networkID: String = String()

  /// Interface name this peer belongs to (wg0, wg1, wg2, etc.)
  public var interfaceName: String = String()

  /// Peer public key
  public var publicKey: String = String()

  /// Peer endpoint (IP:port)
  public var endpoint: String = String()

  /// Allowed IPs for this peer
  public var allowedIps: [String] = []

  /// Latest handshake timestamp (Unix seconds, 0 if never)
  public var latestHandshake: UInt64 = 0

  /// Transfer statistics
  public var stats: Arca_Wireguard_V1_TransferStats {
    get {return _stats ?? Arca_Wireguard_V1_TransferStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  public var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  public mutating func clearStats() {self._stats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stats: Arca_Wireguard_V1_TransferStats? = nil
}

public struct Arca_Wireguard_V1_TransferStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bytes received from this peer
  public var bytesReceived: UInt64 = 0

  /// Bytes sent to this peer
  public var bytesSent: UInt64 = 0

  /// Persistent keepalive interval (seconds, 0 if disabled)
  public var persistentKeepalive: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for vmnet endpoint information
public struct Arca_Wireguard_V1_GetVmnetEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_GetVmnetEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// vmnet endpoint (eth0 IP:port, e.g., "192.168.65.5:51820")
  public var endpoint: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to add a peer to a WireGuard interface
public struct Arca_Wireguard_V1_AddPeerRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID this peer belongs to
  public var networkID: String = String()

  /// Network index (which wgN interface to add peer to)
  public var networkIndex: UInt32 = 0

  /// Peer's WireGuard public key (Base64-encoded)
  public var peerPublicKey: String = String()

  /// Peer's vmnet endpoint (IP:port, e.g., "192.168.65.5:51820")
  public var peerEndpoint: String = String()

  /// Peer's overlay IP address (for allowed-ips routing, e.g., "172.18.0.3")
  public var peerIpAddress: String = String()

  /// Peer's container name (for DNS resolution, e.g., "web1")
  public var peerName: String = String()

  /// Peer's container ID (Docker ID, for logging/debugging)
  public var peerContainerID: String = String()

  /// Peer's DNS aliases (additional names that resolve to this IP)
  public var peerAliases: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_AddPeerResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Total number of peers on this interface
  public var totalPeers: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to remove a peer from a WireGuard interface
public struct Arca_Wireguard_V1_RemovePeerRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Network ID this peer belongs to
  public var networkID: String = String()

  /// Network index (which wgN interface to remove peer from)
  public var networkIndex: UInt32 = 0

  /// Peer's WireGuard public key to remove (Base64-encoded)
  public var peerPublicKey: String = String()

  /// Peer's container name (for DNS entry removal)
  public var peerName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_RemovePeerResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Remaining number of peers on this interface
  public var remainingPeers: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to publish a port (expose container port on host)
public struct Arca_Wireguard_V1_PublishPortRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol ("tcp" or "udp")
  public var `protocol`: String = String()

  /// Host port (port on vmnet interface that macOS host will connect to)
  public var hostPort: UInt32 = 0

  /// Container overlay IP address (WireGuard IP, e.g., "172.18.0.2")
  public var containerIp: String = String()

  /// Container port (port inside container to DNAT to)
  public var containerPort: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_PublishPortResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to unpublish a port (remove port exposure)
public struct Arca_Wireguard_V1_UnpublishPortRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol ("tcp" or "udp")
  public var `protocol`: String = String()

  /// Host port to unpublish
  public var hostPort: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_UnpublishPortResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to dump nftables state for debugging
public struct Arca_Wireguard_V1_DumpNftablesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Arca_Wireguard_V1_DumpNftablesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  /// Full nftables ruleset output (from 'nft list ruleset')
  /// Includes all tables, chains, rules, and packet counters
  public var ruleset: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "arca.wireguard.v1"

extension Arca_Wireguard_V1_ReadyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_ReadyRequest, rhs: Arca_Wireguard_V1_ReadyRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_ReadyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ready\0\u{1}version\0\u{3}uptime_ms\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ready) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.uptimeMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ready != false {
      try visitor.visitSingularBoolField(value: self.ready, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.uptimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.uptimeMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_ReadyResponse, rhs: Arca_Wireguard_V1_ReadyResponse) -> Bool {
    if lhs.ready != rhs.ready {return false}
    if lhs.version != rhs.version {return false}
    if lhs.uptimeMs != rhs.uptimeMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_AddNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddNetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{3}network_index\0\u{3}private_key\0\u{3}listen_port\0\u{3}peer_endpoint\0\u{3}peer_public_key\0\u{3}ip_address\0\u{3}network_cidr\0\u{1}gateway\0\u{3}host_ip\0\u{3}extra_hosts\0\u{3}container_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.networkIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.privateKey) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.listenPort) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.peerEndpoint) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.peerPublicKey) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.networkCidr) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.hostIp) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.extraHosts) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.containerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if self.networkIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.networkIndex, fieldNumber: 2)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKey, fieldNumber: 3)
    }
    if self.listenPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.listenPort, fieldNumber: 4)
    }
    if !self.peerEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.peerEndpoint, fieldNumber: 5)
    }
    if !self.peerPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.peerPublicKey, fieldNumber: 6)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 7)
    }
    if !self.networkCidr.isEmpty {
      try visitor.visitSingularStringField(value: self.networkCidr, fieldNumber: 8)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 9)
    }
    if !self.hostIp.isEmpty {
      try visitor.visitSingularStringField(value: self.hostIp, fieldNumber: 10)
    }
    if !self.extraHosts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.extraHosts, fieldNumber: 11)
    }
    if !self.containerID.isEmpty {
      try visitor.visitSingularStringField(value: self.containerID, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_AddNetworkRequest, rhs: Arca_Wireguard_V1_AddNetworkRequest) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.networkIndex != rhs.networkIndex {return false}
    if lhs.containerID != rhs.containerID {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.listenPort != rhs.listenPort {return false}
    if lhs.peerEndpoint != rhs.peerEndpoint {return false}
    if lhs.peerPublicKey != rhs.peerPublicKey {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.networkCidr != rhs.networkCidr {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.hostIp != rhs.hostIp {return false}
    if lhs.extraHosts != rhs.extraHosts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_AddNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddNetworkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}total_networks\0\u{3}wg_interface\0\u{3}eth_interface\0\u{3}public_key\0\u{3}namespace_path\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalNetworks) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.wgInterface) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ethInterface) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.namespacePath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.totalNetworks != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalNetworks, fieldNumber: 3)
    }
    if !self.wgInterface.isEmpty {
      try visitor.visitSingularStringField(value: self.wgInterface, fieldNumber: 4)
    }
    if !self.ethInterface.isEmpty {
      try visitor.visitSingularStringField(value: self.ethInterface, fieldNumber: 5)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 6)
    }
    if !self.namespacePath.isEmpty {
      try visitor.visitSingularStringField(value: self.namespacePath, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_AddNetworkResponse, rhs: Arca_Wireguard_V1_AddNetworkResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.totalNetworks != rhs.totalNetworks {return false}
    if lhs.wgInterface != rhs.wgInterface {return false}
    if lhs.ethInterface != rhs.ethInterface {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.namespacePath != rhs.namespacePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_RemoveNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveNetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{3}network_index\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.networkIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if self.networkIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.networkIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_RemoveNetworkRequest, rhs: Arca_Wireguard_V1_RemoveNetworkRequest) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.networkIndex != rhs.networkIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_RemoveNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveNetworkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}remaining_networks\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.remainingNetworks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.remainingNetworks != 0 {
      try visitor.visitSingularUInt32Field(value: self.remainingNetworks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_RemoveNetworkResponse, rhs: Arca_Wireguard_V1_RemoveNetworkResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.remainingNetworks != rhs.remainingNetworks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_GetStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_GetStatusRequest, rhs: Arca_Wireguard_V1_GetStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_GetStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}network_count\0\u{1}interfaces\0\u{1}peers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.networkCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.interfaces) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.networkCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.networkCount, fieldNumber: 2)
    }
    if !self.interfaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaces, fieldNumber: 3)
    }
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_GetStatusResponse, rhs: Arca_Wireguard_V1_GetStatusResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.networkCount != rhs.networkCount {return false}
    if lhs.interfaces != rhs.interfaces {return false}
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_InterfaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InterfaceStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{1}name\0\u{3}public_key\0\u{3}listen_port\0\u{3}ip_addresses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.listenPort) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.ipAddresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if self.listenPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.listenPort, fieldNumber: 4)
    }
    if !self.ipAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipAddresses, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_InterfaceStatus, rhs: Arca_Wireguard_V1_InterfaceStatus) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.listenPort != rhs.listenPort {return false}
    if lhs.ipAddresses != rhs.ipAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_PeerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeerStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{3}interface_name\0\u{3}public_key\0\u{1}endpoint\0\u{3}allowed_ips\0\u{3}latest_handshake\0\u{1}stats\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.allowedIps) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.latestHandshake) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 4)
    }
    if !self.allowedIps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedIps, fieldNumber: 5)
    }
    if self.latestHandshake != 0 {
      try visitor.visitSingularUInt64Field(value: self.latestHandshake, fieldNumber: 6)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_PeerStatus, rhs: Arca_Wireguard_V1_PeerStatus) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.allowedIps != rhs.allowedIps {return false}
    if lhs.latestHandshake != rhs.latestHandshake {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_TransferStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferStats"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bytes_received\0\u{3}bytes_sent\0\u{3}persistent_keepalive\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bytesReceived) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bytesSent) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.persistentKeepalive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytesReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesReceived, fieldNumber: 1)
    }
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 2)
    }
    if self.persistentKeepalive != 0 {
      try visitor.visitSingularUInt32Field(value: self.persistentKeepalive, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_TransferStats, rhs: Arca_Wireguard_V1_TransferStats) -> Bool {
    if lhs.bytesReceived != rhs.bytesReceived {return false}
    if lhs.bytesSent != rhs.bytesSent {return false}
    if lhs.persistentKeepalive != rhs.persistentKeepalive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_GetVmnetEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVmnetEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_GetVmnetEndpointRequest, rhs: Arca_Wireguard_V1_GetVmnetEndpointRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_GetVmnetEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVmnetEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{1}endpoint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_GetVmnetEndpointResponse, rhs: Arca_Wireguard_V1_GetVmnetEndpointResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_AddPeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddPeerRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{3}network_index\0\u{3}peer_public_key\0\u{3}peer_endpoint\0\u{3}peer_ip_address\0\u{3}peer_name\0\u{3}peer_container_id\0\u{3}peer_aliases\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.networkIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.peerPublicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.peerEndpoint) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.peerIpAddress) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.peerName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.peerContainerID) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.peerAliases) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if self.networkIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.networkIndex, fieldNumber: 2)
    }
    if !self.peerPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.peerPublicKey, fieldNumber: 3)
    }
    if !self.peerEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.peerEndpoint, fieldNumber: 4)
    }
    if !self.peerIpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.peerIpAddress, fieldNumber: 5)
    }
    if !self.peerName.isEmpty {
      try visitor.visitSingularStringField(value: self.peerName, fieldNumber: 6)
    }
    if !self.peerContainerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerContainerID, fieldNumber: 7)
    }
    if !self.peerAliases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.peerAliases, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_AddPeerRequest, rhs: Arca_Wireguard_V1_AddPeerRequest) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.networkIndex != rhs.networkIndex {return false}
    if lhs.peerPublicKey != rhs.peerPublicKey {return false}
    if lhs.peerEndpoint != rhs.peerEndpoint {return false}
    if lhs.peerIpAddress != rhs.peerIpAddress {return false}
    if lhs.peerName != rhs.peerName {return false}
    if lhs.peerContainerID != rhs.peerContainerID {return false}
    if lhs.peerAliases != rhs.peerAliases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_AddPeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddPeerResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}total_peers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalPeers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.totalPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalPeers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_AddPeerResponse, rhs: Arca_Wireguard_V1_AddPeerResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.totalPeers != rhs.totalPeers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_RemovePeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemovePeerRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}network_id\0\u{3}network_index\0\u{3}peer_public_key\0\u{3}peer_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.networkIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.peerPublicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.peerName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkID.isEmpty {
      try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 1)
    }
    if self.networkIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.networkIndex, fieldNumber: 2)
    }
    if !self.peerPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.peerPublicKey, fieldNumber: 3)
    }
    if !self.peerName.isEmpty {
      try visitor.visitSingularStringField(value: self.peerName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_RemovePeerRequest, rhs: Arca_Wireguard_V1_RemovePeerRequest) -> Bool {
    if lhs.networkID != rhs.networkID {return false}
    if lhs.networkIndex != rhs.networkIndex {return false}
    if lhs.peerPublicKey != rhs.peerPublicKey {return false}
    if lhs.peerName != rhs.peerName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_RemovePeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemovePeerResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{3}remaining_peers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.remainingPeers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.remainingPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.remainingPeers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_RemovePeerResponse, rhs: Arca_Wireguard_V1_RemovePeerResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.remainingPeers != rhs.remainingPeers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_PublishPortRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishPortRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}protocol\0\u{3}host_port\0\u{3}container_ip\0\u{3}container_port\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.hostPort) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.containerIp) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.containerPort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 1)
    }
    if self.hostPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.hostPort, fieldNumber: 2)
    }
    if !self.containerIp.isEmpty {
      try visitor.visitSingularStringField(value: self.containerIp, fieldNumber: 3)
    }
    if self.containerPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.containerPort, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_PublishPortRequest, rhs: Arca_Wireguard_V1_PublishPortRequest) -> Bool {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.hostPort != rhs.hostPort {return false}
    if lhs.containerIp != rhs.containerIp {return false}
    if lhs.containerPort != rhs.containerPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_PublishPortResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishPortResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_PublishPortResponse, rhs: Arca_Wireguard_V1_PublishPortResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_UnpublishPortRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnpublishPortRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}protocol\0\u{3}host_port\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.hostPort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 1)
    }
    if self.hostPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.hostPort, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_UnpublishPortRequest, rhs: Arca_Wireguard_V1_UnpublishPortRequest) -> Bool {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.hostPort != rhs.hostPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_UnpublishPortResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnpublishPortResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_UnpublishPortResponse, rhs: Arca_Wireguard_V1_UnpublishPortResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_DumpNftablesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DumpNftablesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_DumpNftablesRequest, rhs: Arca_Wireguard_V1_DumpNftablesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Arca_Wireguard_V1_DumpNftablesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DumpNftablesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{1}ruleset\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ruleset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.ruleset.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Arca_Wireguard_V1_DumpNftablesResponse, rhs: Arca_Wireguard_V1_DumpNftablesResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.ruleset != rhs.ruleset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
