// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: router.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Router_CreateVLANRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VLAN ID (100-4094)
  public var vlanID: UInt32 = 0

  /// Network subnet in CIDR notation (e.g., "172.18.0.0/16")
  public var subnet: String = String()

  /// Gateway IP address (e.g., "172.18.0.1")
  /// This IP will be assigned to the VLAN interface
  public var gateway: String = String()

  /// Network name (for DNS/logging)
  public var networkName: String = String()

  /// Optional: MTU for the VLAN interface
  public var mtu: UInt32 = 0

  /// Optional: Enable NAT for this network (default: true)
  public var enableNat: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_CreateVLANResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Created interface name (e.g., "eth0.100")
  public var interfaceName: String = String()

  /// Gateway MAC address
  public var macAddress: String = String()

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_DeleteVLANRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VLAN ID to delete
  public var vlanID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_DeleteVLANResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_ConfigureNATRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VLAN ID
  public var vlanID: UInt32 = 0

  /// Source subnet to NAT (e.g., "172.18.0.0/16")
  public var sourceSubnet: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_ConfigureNATResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_RemoveNATRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VLAN ID
  public var vlanID: UInt32 = 0

  /// Source subnet that was NATed
  public var sourceSubnet: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_RemoveNATResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_ConfigureDNSRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VLAN ID
  public var vlanID: UInt32 = 0

  /// Network subnet (e.g., "172.18.0.0/16")
  public var subnet: String = String()

  /// Gateway IP (DNS server will listen here)
  public var gateway: String = String()

  /// DNS domain for container name resolution
  /// e.g., "frontend.docker.internal"
  public var domain: String = String()

  /// Container hostname â†’ IP mappings
  public var hosts: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_ConfigureDNSResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_AddPortMappingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Container IP address
  public var containerIp: String = String()

  /// Container port
  public var containerPort: UInt32 = 0

  /// Host port to expose
  public var hostPort: UInt32 = 0

  /// Protocol (tcp/udp)
  public var `protocol`: String = String()

  /// VLAN ID (for routing back to container)
  public var vlanID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_AddPortMappingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_RemovePortMappingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Host port to remove
  public var hostPort: UInt32 = 0

  /// Protocol (tcp/udp)
  public var `protocol`: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_RemovePortMappingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success status
  public var success: Bool = false

  /// Error message if success = false
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_ListVLANsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional: Filter by VLAN ID
  public var vlanID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_ListVLANsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of VLAN interfaces
  public var vlans: [Router_VLANInterface] = []

  /// Error message if retrieval failed
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_VLANInterface: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VLAN ID
  public var vlanID: UInt32 = 0

  /// Interface name (e.g., "eth0.100")
  public var interfaceName: String = String()

  /// Gateway IP address
  public var gateway: String = String()

  /// Subnet in CIDR notation
  public var subnet: String = String()

  /// MAC address
  public var macAddress: String = String()

  /// MTU
  public var mtu: UInt32 = 0

  /// Interface is up
  public var isUp: Bool = false

  /// NAT enabled
  public var natEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// No parameters
public struct Router_HealthRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Router_HealthResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Service is healthy
  public var healthy: Bool = false

  /// Status message
  public var status: String = String()

  /// Number of active VLANs
  public var activeVlans: UInt32 = 0

  /// Service uptime in seconds
  public var uptimeSeconds: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "router"

extension Router_CreateVLANRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVLANRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}vlan_id\0\u{1}subnet\0\u{1}gateway\0\u{3}network_name\0\u{1}mtu\0\u{3}enable_nat\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subnet) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.networkName) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.mtu) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enableNat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 1)
    }
    if !self.subnet.isEmpty {
      try visitor.visitSingularStringField(value: self.subnet, fieldNumber: 2)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 3)
    }
    if !self.networkName.isEmpty {
      try visitor.visitSingularStringField(value: self.networkName, fieldNumber: 4)
    }
    if self.mtu != 0 {
      try visitor.visitSingularUInt32Field(value: self.mtu, fieldNumber: 5)
    }
    if self.enableNat != false {
      try visitor.visitSingularBoolField(value: self.enableNat, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_CreateVLANRequest, rhs: Router_CreateVLANRequest) -> Bool {
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.subnet != rhs.subnet {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.networkName != rhs.networkName {return false}
    if lhs.mtu != rhs.mtu {return false}
    if lhs.enableNat != rhs.enableNat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_CreateVLANResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateVLANResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}interface_name\0\u{3}mac_address\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 2)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 3)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_CreateVLANResponse, rhs: Router_CreateVLANResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_DeleteVLANRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteVLANRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}vlan_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_DeleteVLANRequest, rhs: Router_DeleteVLANRequest) -> Bool {
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_DeleteVLANResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteVLANResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_DeleteVLANResponse, rhs: Router_DeleteVLANResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_ConfigureNATRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureNATRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}vlan_id\0\u{3}source_subnet\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubnet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 1)
    }
    if !self.sourceSubnet.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubnet, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_ConfigureNATRequest, rhs: Router_ConfigureNATRequest) -> Bool {
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.sourceSubnet != rhs.sourceSubnet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_ConfigureNATResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureNATResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_ConfigureNATResponse, rhs: Router_ConfigureNATResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_RemoveNATRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveNATRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}vlan_id\0\u{3}source_subnet\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubnet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 1)
    }
    if !self.sourceSubnet.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubnet, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_RemoveNATRequest, rhs: Router_RemoveNATRequest) -> Bool {
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.sourceSubnet != rhs.sourceSubnet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_RemoveNATResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveNATResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_RemoveNATResponse, rhs: Router_RemoveNATResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_ConfigureDNSRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureDNSRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}vlan_id\0\u{1}subnet\0\u{1}gateway\0\u{1}domain\0\u{1}hosts\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subnet) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.hosts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 1)
    }
    if !self.subnet.isEmpty {
      try visitor.visitSingularStringField(value: self.subnet, fieldNumber: 2)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 3)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 4)
    }
    if !self.hosts.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.hosts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_ConfigureDNSRequest, rhs: Router_ConfigureDNSRequest) -> Bool {
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.subnet != rhs.subnet {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.hosts != rhs.hosts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_ConfigureDNSResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureDNSResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_ConfigureDNSResponse, rhs: Router_ConfigureDNSResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_AddPortMappingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddPortMappingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}container_ip\0\u{3}container_port\0\u{3}host_port\0\u{1}protocol\0\u{3}vlan_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.containerIp) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.containerPort) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.hostPort) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.containerIp.isEmpty {
      try visitor.visitSingularStringField(value: self.containerIp, fieldNumber: 1)
    }
    if self.containerPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.containerPort, fieldNumber: 2)
    }
    if self.hostPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.hostPort, fieldNumber: 3)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 4)
    }
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_AddPortMappingRequest, rhs: Router_AddPortMappingRequest) -> Bool {
    if lhs.containerIp != rhs.containerIp {return false}
    if lhs.containerPort != rhs.containerPort {return false}
    if lhs.hostPort != rhs.hostPort {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_AddPortMappingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddPortMappingResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_AddPortMappingResponse, rhs: Router_AddPortMappingResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_RemovePortMappingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemovePortMappingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}host_port\0\u{1}protocol\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.hostPort) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hostPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.hostPort, fieldNumber: 1)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_RemovePortMappingRequest, rhs: Router_RemovePortMappingRequest) -> Bool {
    if lhs.hostPort != rhs.hostPort {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_RemovePortMappingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemovePortMappingResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_RemovePortMappingResponse, rhs: Router_RemovePortMappingResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_ListVLANsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListVLANsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}vlan_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_ListVLANsRequest, rhs: Router_ListVLANsRequest) -> Bool {
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_ListVLANsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListVLANsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vlans\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vlans) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vlans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vlans, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_ListVLANsResponse, rhs: Router_ListVLANsResponse) -> Bool {
    if lhs.vlans != rhs.vlans {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_VLANInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VLANInterface"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}vlan_id\0\u{3}interface_name\0\u{1}gateway\0\u{1}subnet\0\u{3}mac_address\0\u{1}mtu\0\u{3}is_up\0\u{3}nat_enabled\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vlanID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subnet) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.mtu) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isUp) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.natEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vlanID != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlanID, fieldNumber: 1)
    }
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 2)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 3)
    }
    if !self.subnet.isEmpty {
      try visitor.visitSingularStringField(value: self.subnet, fieldNumber: 4)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 5)
    }
    if self.mtu != 0 {
      try visitor.visitSingularUInt32Field(value: self.mtu, fieldNumber: 6)
    }
    if self.isUp != false {
      try visitor.visitSingularBoolField(value: self.isUp, fieldNumber: 7)
    }
    if self.natEnabled != false {
      try visitor.visitSingularBoolField(value: self.natEnabled, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_VLANInterface, rhs: Router_VLANInterface) -> Bool {
    if lhs.vlanID != rhs.vlanID {return false}
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.subnet != rhs.subnet {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.mtu != rhs.mtu {return false}
    if lhs.isUp != rhs.isUp {return false}
    if lhs.natEnabled != rhs.natEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_HealthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_HealthRequest, rhs: Router_HealthRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Router_HealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}healthy\0\u{1}status\0\u{3}active_vlans\0\u{3}uptime_seconds\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.healthy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.activeVlans) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.uptimeSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.healthy != false {
      try visitor.visitSingularBoolField(value: self.healthy, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    if self.activeVlans != 0 {
      try visitor.visitSingularUInt32Field(value: self.activeVlans, fieldNumber: 3)
    }
    if self.uptimeSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.uptimeSeconds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Router_HealthResponse, rhs: Router_HealthResponse) -> Bool {
    if lhs.healthy != rhs.healthy {return false}
    if lhs.status != rhs.status {return false}
    if lhs.activeVlans != rhs.activeVlans {return false}
    if lhs.uptimeSeconds != rhs.uptimeSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
