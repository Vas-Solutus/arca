// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: github.com/moby/buildkit/solver/pb/ops.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Pb_NetMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// sandbox
  case unset // = 0
  case host // = 1
  case none // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .host
    case 2: self = .none
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unset: return 0
    case .host: return 1
    case .none: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pb_NetMode] = [
    .unset,
    .host,
    .none,
  ]

}

public enum Pb_SecurityMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case sandbox // = 0

  /// privileged mode
  case insecure // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .sandbox
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sandbox
    case 1: self = .insecure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sandbox: return 0
    case .insecure: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pb_SecurityMode] = [
    .sandbox,
    .insecure,
  ]

}

/// MountType defines a type of a mount from a supported set
public enum Pb_MountType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case bind // = 0
  case secret // = 1
  case ssh // = 2
  case cache // = 3
  case tmpfs // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .bind
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bind
    case 1: self = .secret
    case 2: self = .ssh
    case 3: self = .cache
    case 4: self = .tmpfs
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .bind: return 0
    case .secret: return 1
    case .ssh: return 2
    case .cache: return 3
    case .tmpfs: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pb_MountType] = [
    .bind,
    .secret,
    .ssh,
    .cache,
    .tmpfs,
  ]

}

/// MountContentCache ...
public enum Pb_MountContentCache: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case `default` // = 0
  case on // = 1
  case off // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .on
    case 2: self = .off
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .on: return 1
    case .off: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pb_MountContentCache] = [
    .default,
    .on,
    .off,
  ]

}

/// CacheSharingOpt defines different sharing modes for cache mount
public enum Pb_CacheSharingOpt: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// SHARED cache mount can be used concurrently by multiple writers
  case shared // = 0

  /// PRIVATE creates a new mount if there are multiple writers
  case `private` // = 1

  /// LOCKED pauses second writer until first one releases the mount
  case locked // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .shared
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .shared
    case 1: self = .private
    case 2: self = .locked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .shared: return 0
    case .private: return 1
    case .locked: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pb_CacheSharingOpt] = [
    .shared,
    .private,
    .locked,
  ]

}

/// Op represents a vertex of the LLB DAG.
public struct Pb_Op: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// changes to this structure must be represented in json.go.
  /// inputs is a set of input edges.
  public var inputs: [Pb_Input] = []

  public var op: Pb_Op.OneOf_Op? = nil

  public var exec: Pb_ExecOp {
    get {
      if case .exec(let v)? = op {return v}
      return Pb_ExecOp()
    }
    set {op = .exec(newValue)}
  }

  public var source: Pb_SourceOp {
    get {
      if case .source(let v)? = op {return v}
      return Pb_SourceOp()
    }
    set {op = .source(newValue)}
  }

  public var file: Pb_FileOp {
    get {
      if case .file(let v)? = op {return v}
      return Pb_FileOp()
    }
    set {op = .file(newValue)}
  }

  public var build: Pb_BuildOp {
    get {
      if case .build(let v)? = op {return v}
      return Pb_BuildOp()
    }
    set {op = .build(newValue)}
  }

  public var merge: Pb_MergeOp {
    get {
      if case .merge(let v)? = op {return v}
      return Pb_MergeOp()
    }
    set {op = .merge(newValue)}
  }

  public var diff: Pb_DiffOp {
    get {
      if case .diff(let v)? = op {return v}
      return Pb_DiffOp()
    }
    set {op = .diff(newValue)}
  }

  public var platform: Pb_Platform {
    get {return _platform ?? Pb_Platform()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  public var constraints: Pb_WorkerConstraints {
    get {return _constraints ?? Pb_WorkerConstraints()}
    set {_constraints = newValue}
  }
  /// Returns true if `constraints` has been explicitly set.
  public var hasConstraints: Bool {return self._constraints != nil}
  /// Clears the value of `constraints`. Subsequent reads from it will return its default value.
  public mutating func clearConstraints() {self._constraints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Op: Equatable, Sendable {
    case exec(Pb_ExecOp)
    case source(Pb_SourceOp)
    case file(Pb_FileOp)
    case build(Pb_BuildOp)
    case merge(Pb_MergeOp)
    case diff(Pb_DiffOp)

  }

  public init() {}

  fileprivate var _platform: Pb_Platform? = nil
  fileprivate var _constraints: Pb_WorkerConstraints? = nil
}

/// Platform is github.com/opencontainers/image-spec/specs-go/v1.Platform
public struct Pb_Platform: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var architecture: String = String()

  public var os: String = String()

  public var variant: String = String()

  public var osversion: String = String()

  /// unused
  public var osfeatures: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Input represents an input edge for an Op.
public struct Pb_Input: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// digest of the marshaled input Op
  public var digest: String = String()

  /// output index of the input Op
  public var index: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ExecOp executes a command in a container.
public struct Pb_ExecOp: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var meta: Pb_Meta {
    get {return _storage._meta ?? Pb_Meta()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {_uniqueStorage()._meta = nil}

  public var mounts: [Pb_Mount] {
    get {return _storage._mounts}
    set {_uniqueStorage()._mounts = newValue}
  }

  public var network: Pb_NetMode {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  public var security: Pb_SecurityMode {
    get {return _storage._security}
    set {_uniqueStorage()._security = newValue}
  }

  public var secretenv: [Pb_SecretEnv] {
    get {return _storage._secretenv}
    set {_uniqueStorage()._secretenv = newValue}
  }

  public var cdiDevices: [Pb_CDIDevice] {
    get {return _storage._cdiDevices}
    set {_uniqueStorage()._cdiDevices = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Meta is a set of arguments for ExecOp.
/// Meta is unrelated to LLB metadata.
/// FIXME: rename (ExecContext? ExecArgs?)
public struct Pb_Meta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var args: [String] = []

  public var env: [String] = []

  public var cwd: String = String()

  public var user: String = String()

  public var proxyEnv: Pb_ProxyEnv {
    get {return _proxyEnv ?? Pb_ProxyEnv()}
    set {_proxyEnv = newValue}
  }
  /// Returns true if `proxyEnv` has been explicitly set.
  public var hasProxyEnv: Bool {return self._proxyEnv != nil}
  /// Clears the value of `proxyEnv`. Subsequent reads from it will return its default value.
  public mutating func clearProxyEnv() {self._proxyEnv = nil}

  public var extraHosts: [Pb_HostIP] = []

  public var hostname: String = String()

  public var ulimit: [Pb_Ulimit] = []

  public var cgroupParent: String = String()

  public var removeMountStubsRecursive: Bool = false

  public var validExitCodes: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _proxyEnv: Pb_ProxyEnv? = nil
}

public struct Pb_HostIP: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var ip: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_Ulimit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var soft: Int64 = 0

  public var hard: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SecretEnv is an environment variable that is backed by a secret.
public struct Pb_SecretEnv: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var optional: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CDIDevice specifies a CDI device information.
public struct Pb_CDIDevice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fully qualified CDI device name (e.g., vendor.com/gpu=gpudevice1)
  /// https://github.com/cncf-tags/container-device-interface/blob/main/SPEC.md
  public var name: String = String()

  /// Optional defines if CDI device is required.
  public var optional: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Mount specifies how to mount an input Op as a filesystem.
public struct Pb_Mount: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: Int64 {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  public var selector: String {
    get {return _storage._selector}
    set {_uniqueStorage()._selector = newValue}
  }

  public var dest: String {
    get {return _storage._dest}
    set {_uniqueStorage()._dest = newValue}
  }

  public var output: Int64 {
    get {return _storage._output}
    set {_uniqueStorage()._output = newValue}
  }

  public var readonly: Bool {
    get {return _storage._readonly}
    set {_uniqueStorage()._readonly = newValue}
  }

  public var mountType: Pb_MountType {
    get {return _storage._mountType}
    set {_uniqueStorage()._mountType = newValue}
  }

  public var tmpfsOpt: Pb_TmpfsOpt {
    get {return _storage._tmpfsOpt ?? Pb_TmpfsOpt()}
    set {_uniqueStorage()._tmpfsOpt = newValue}
  }
  /// Returns true if `tmpfsOpt` has been explicitly set.
  public var hasTmpfsOpt: Bool {return _storage._tmpfsOpt != nil}
  /// Clears the value of `tmpfsOpt`. Subsequent reads from it will return its default value.
  public mutating func clearTmpfsOpt() {_uniqueStorage()._tmpfsOpt = nil}

  public var cacheOpt: Pb_CacheOpt {
    get {return _storage._cacheOpt ?? Pb_CacheOpt()}
    set {_uniqueStorage()._cacheOpt = newValue}
  }
  /// Returns true if `cacheOpt` has been explicitly set.
  public var hasCacheOpt: Bool {return _storage._cacheOpt != nil}
  /// Clears the value of `cacheOpt`. Subsequent reads from it will return its default value.
  public mutating func clearCacheOpt() {_uniqueStorage()._cacheOpt = nil}

  public var secretOpt: Pb_SecretOpt {
    get {return _storage._secretOpt ?? Pb_SecretOpt()}
    set {_uniqueStorage()._secretOpt = newValue}
  }
  /// Returns true if `secretOpt` has been explicitly set.
  public var hasSecretOpt: Bool {return _storage._secretOpt != nil}
  /// Clears the value of `secretOpt`. Subsequent reads from it will return its default value.
  public mutating func clearSecretOpt() {_uniqueStorage()._secretOpt = nil}

  public var sshopt: Pb_SSHOpt {
    get {return _storage._sshopt ?? Pb_SSHOpt()}
    set {_uniqueStorage()._sshopt = newValue}
  }
  /// Returns true if `sshopt` has been explicitly set.
  public var hasSshopt: Bool {return _storage._sshopt != nil}
  /// Clears the value of `sshopt`. Subsequent reads from it will return its default value.
  public mutating func clearSshopt() {_uniqueStorage()._sshopt = nil}

  public var resultID: String {
    get {return _storage._resultID}
    set {_uniqueStorage()._resultID = newValue}
  }

  public var contentCache: Pb_MountContentCache {
    get {return _storage._contentCache}
    set {_uniqueStorage()._contentCache = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TmpfsOpt defines options describing tpmfs mounts
public struct Pb_TmpfsOpt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify an upper limit on the size of the filesystem.
  public var size: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CacheOpt defines options specific to cache mounts
public struct Pb_CacheOpt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is an optional namespace for the mount
  public var id: String = String()

  /// Sharing is the sharing mode for the mount
  public var sharing: Pb_CacheSharingOpt = .shared

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SecretOpt defines options describing secret mounts
public struct Pb_SecretOpt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of secret. Used for quering the value.
  public var id: String = String()

  /// UID of secret file
  public var uid: UInt32 = 0

  /// GID of secret file
  public var gid: UInt32 = 0

  /// Mode is the filesystem mode of secret file
  public var mode: UInt32 = 0

  /// Optional defines if secret value is required. Error is produced
  /// if value is not found and optional is false.
  public var optional: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SSHOpt defines options describing ssh mounts
public struct Pb_SSHOpt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of exposed ssh rule. Used for quering the value.
  public var id: String = String()

  /// UID of agent socket
  public var uid: UInt32 = 0

  /// GID of agent socket
  public var gid: UInt32 = 0

  /// Mode is the filesystem mode of agent socket
  public var mode: UInt32 = 0

  /// Optional defines if ssh socket is required. Error is produced
  /// if client does not expose ssh.
  public var optional: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SourceOp specifies a source such as build contexts and images.
public struct Pb_SourceOp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: use source type or any type instead of URL protocol.
  /// identifier e.g. local://, docker-image://, git://, https://...
  public var identifier: String = String()

  /// attrs are defined in attr.go
  public var attrs: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BuildOp is used for nested build invocation.
/// BuildOp is experimental and can break without backwards compatibility
public struct Pb_BuildOp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var builder: Int64 = 0

  public var inputs: Dictionary<String,Pb_BuildInput> = [:]

  public var def: Pb_Definition {
    get {return _def ?? Pb_Definition()}
    set {_def = newValue}
  }
  /// Returns true if `def` has been explicitly set.
  public var hasDef: Bool {return self._def != nil}
  /// Clears the value of `def`. Subsequent reads from it will return its default value.
  public mutating func clearDef() {self._def = nil}

  /// outputs
  public var attrs: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _def: Pb_Definition? = nil
}

/// BuildInput is used for BuildOp.
public struct Pb_BuildInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// OpMetadata is a per-vertex metadata entry, which can be defined for arbitrary Op vertex and overridable on the run time.
public struct Pb_OpMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ignore_cache specifies to ignore the cache for this Op.
  public var ignoreCache: Bool = false

  /// Description can be used for keeping any text fields that builder doesn't parse
  public var description_p: Dictionary<String,String> = [:]

  /// index 3 reserved for WorkerConstraint in previous versions
  /// WorkerConstraint worker_constraint = 3;
  public var exportCache: Pb_ExportCache {
    get {return _exportCache ?? Pb_ExportCache()}
    set {_exportCache = newValue}
  }
  /// Returns true if `exportCache` has been explicitly set.
  public var hasExportCache: Bool {return self._exportCache != nil}
  /// Clears the value of `exportCache`. Subsequent reads from it will return its default value.
  public mutating func clearExportCache() {self._exportCache = nil}

  public var caps: Dictionary<String,Bool> = [:]

  public var progressGroup: Pb_ProgressGroup {
    get {return _progressGroup ?? Pb_ProgressGroup()}
    set {_progressGroup = newValue}
  }
  /// Returns true if `progressGroup` has been explicitly set.
  public var hasProgressGroup: Bool {return self._progressGroup != nil}
  /// Clears the value of `progressGroup`. Subsequent reads from it will return its default value.
  public mutating func clearProgressGroup() {self._progressGroup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exportCache: Pb_ExportCache? = nil
  fileprivate var _progressGroup: Pb_ProgressGroup? = nil
}

/// Source is a source mapping description for a file
public struct Pb_Source: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var locations: Dictionary<String,Pb_Locations> = [:]

  public var infos: [Pb_SourceInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Locations is a list of ranges with a index to its source map.
public struct Pb_Locations: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var locations: [Pb_Location] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Source info contains the shared metadata of a source mapping
public struct Pb_SourceInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filename: String = String()

  public var data: Data = Data()

  public var definition: Pb_Definition {
    get {return _definition ?? Pb_Definition()}
    set {_definition = newValue}
  }
  /// Returns true if `definition` has been explicitly set.
  public var hasDefinition: Bool {return self._definition != nil}
  /// Clears the value of `definition`. Subsequent reads from it will return its default value.
  public mutating func clearDefinition() {self._definition = nil}

  public var language: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _definition: Pb_Definition? = nil
}

/// Location defines list of areas in to source file
public struct Pb_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sourceIndex: Int32 = 0

  public var ranges: [Pb_Range] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Range is an area in the source file
public struct Pb_Range: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var start: Pb_Position {
    get {return _start ?? Pb_Position()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  public var end: Pb_Position {
    get {return _end ?? Pb_Position()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: Pb_Position? = nil
  fileprivate var _end: Pb_Position? = nil
}

/// Position is single location in a source file
public struct Pb_Position: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var line: Int32 = 0

  public var character: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ExportCache: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ProgressGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var weak: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ProxyEnv: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var httpProxy: String = String()

  public var httpsProxy: String = String()

  public var ftpProxy: String = String()

  public var noProxy: String = String()

  public var allProxy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// WorkerConstraints defines conditions for the worker
public struct Pb_WorkerConstraints: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// containerd-style filter
  public var filter: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Definition is the LLB definition structure with per-vertex metadata entries
public struct Pb_Definition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// def is a list of marshaled Op messages
  public var def: [Data] = []

  /// metadata contains metadata for the each of the Op messages.
  /// A key must be an LLB op digest string. Currently, empty string is not expected as a key, but it may change in the future.
  public var metadata: Dictionary<String,Pb_OpMetadata> = [:]

  /// Source contains the source mapping information for the vertexes in the definition
  public var source: Pb_Source {
    get {return _source ?? Pb_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Pb_Source? = nil
}

public struct Pb_FileOp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actions: [Pb_FileAction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_FileAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// changes to this structure must be represented in json.go.
  public var input: Int64 = 0

  /// --//--
  public var secondaryInput: Int64 = 0

  public var output: Int64 = 0

  public var action: Pb_FileAction.OneOf_Action? = nil

  /// FileActionCopy copies files from secondaryInput on top of input
  public var copy: Pb_FileActionCopy {
    get {
      if case .copy(let v)? = action {return v}
      return Pb_FileActionCopy()
    }
    set {action = .copy(newValue)}
  }

  /// FileActionMkFile creates a new file
  public var mkfile: Pb_FileActionMkFile {
    get {
      if case .mkfile(let v)? = action {return v}
      return Pb_FileActionMkFile()
    }
    set {action = .mkfile(newValue)}
  }

  /// FileActionMkDir creates a new directory
  public var mkdir: Pb_FileActionMkDir {
    get {
      if case .mkdir(let v)? = action {return v}
      return Pb_FileActionMkDir()
    }
    set {action = .mkdir(newValue)}
  }

  /// FileActionRm removes a file
  public var rm: Pb_FileActionRm {
    get {
      if case .rm(let v)? = action {return v}
      return Pb_FileActionRm()
    }
    set {action = .rm(newValue)}
  }

  /// FileActionSymlink creates a symlink
  public var symlink: Pb_FileActionSymlink {
    get {
      if case .symlink(let v)? = action {return v}
      return Pb_FileActionSymlink()
    }
    set {action = .symlink(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable, Sendable {
    /// FileActionCopy copies files from secondaryInput on top of input
    case copy(Pb_FileActionCopy)
    /// FileActionMkFile creates a new file
    case mkfile(Pb_FileActionMkFile)
    /// FileActionMkDir creates a new directory
    case mkdir(Pb_FileActionMkDir)
    /// FileActionRm removes a file
    case rm(Pb_FileActionRm)
    /// FileActionSymlink creates a symlink
    case symlink(Pb_FileActionSymlink)

  }

  public init() {}
}

public struct Pb_FileActionCopy: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// src is the source path
  public var src: String {
    get {return _storage._src}
    set {_uniqueStorage()._src = newValue}
  }

  /// dest path
  public var dest: String {
    get {return _storage._dest}
    set {_uniqueStorage()._dest = newValue}
  }

  /// optional owner override
  public var owner: Pb_ChownOpt {
    get {return _storage._owner ?? Pb_ChownOpt()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  /// optional permission bits override
  public var mode: Int32 {
    get {return _storage._mode}
    set {_uniqueStorage()._mode = newValue}
  }

  /// followSymlink resolves symlinks in src
  public var followSymlink: Bool {
    get {return _storage._followSymlink}
    set {_uniqueStorage()._followSymlink = newValue}
  }

  /// dirCopyContents only copies contents if src is a directory
  public var dirCopyContents: Bool {
    get {return _storage._dirCopyContents}
    set {_uniqueStorage()._dirCopyContents = newValue}
  }

  /// attemptUnpackDockerCompatibility detects if src is an archive to unpack it instead
  public var attemptUnpackDockerCompatibility: Bool {
    get {return _storage._attemptUnpackDockerCompatibility}
    set {_uniqueStorage()._attemptUnpackDockerCompatibility = newValue}
  }

  /// createDestPath creates dest path directories if needed
  public var createDestPath: Bool {
    get {return _storage._createDestPath}
    set {_uniqueStorage()._createDestPath = newValue}
  }

  /// allowWildcard allows filepath.Match wildcards in src path
  public var allowWildcard: Bool {
    get {return _storage._allowWildcard}
    set {_uniqueStorage()._allowWildcard = newValue}
  }

  /// allowEmptyWildcard doesn't fail the whole copy if wildcard doesn't resolve to files
  public var allowEmptyWildcard: Bool {
    get {return _storage._allowEmptyWildcard}
    set {_uniqueStorage()._allowEmptyWildcard = newValue}
  }

  /// optional created time override
  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// include only files/dirs matching at least one of these patterns
  public var includePatterns: [String] {
    get {return _storage._includePatterns}
    set {_uniqueStorage()._includePatterns = newValue}
  }

  /// exclude files/dir matching any of these patterns (even if they match an include pattern)
  public var excludePatterns: [String] {
    get {return _storage._excludePatterns}
    set {_uniqueStorage()._excludePatterns = newValue}
  }

  /// alwaysReplaceExistingDestPaths results in an existing dest path that differs in type from the src path being replaced rather than the default of returning an error
  public var alwaysReplaceExistingDestPaths: Bool {
    get {return _storage._alwaysReplaceExistingDestPaths}
    set {_uniqueStorage()._alwaysReplaceExistingDestPaths = newValue}
  }

  /// mode in non-octal format
  public var modeStr: String {
    get {return _storage._modeStr}
    set {_uniqueStorage()._modeStr = newValue}
  }

  /// required paths that must be included in the copy. This is only used when
  /// include_patterns has at least one pattern.
  public var requiredPaths: [String] {
    get {return _storage._requiredPaths}
    set {_uniqueStorage()._requiredPaths = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pb_FileActionMkFile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// path for the new file
  public var path: String = String()

  /// permission bits
  public var mode: Int32 = 0

  /// data is the new file contents
  public var data: Data = Data()

  /// optional owner for the new file
  public var owner: Pb_ChownOpt {
    get {return _owner ?? Pb_ChownOpt()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// optional created time override
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Pb_ChownOpt? = nil
}

public struct Pb_FileActionSymlink: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// destination path for the new file representing the link
  public var oldpath: String = String()

  /// source path for the link
  public var newpath: String = String()

  /// optional owner for the new file
  public var owner: Pb_ChownOpt {
    get {return _owner ?? Pb_ChownOpt()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// optional created time override
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Pb_ChownOpt? = nil
}

public struct Pb_FileActionMkDir: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// path for the new directory
  public var path: String = String()

  /// permission bits
  public var mode: Int32 = 0

  /// makeParents creates parent directories as well if needed
  public var makeParents: Bool = false

  /// optional owner for the new directory
  public var owner: Pb_ChownOpt {
    get {return _owner ?? Pb_ChownOpt()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// optional created time override
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Pb_ChownOpt? = nil
}

public struct Pb_FileActionRm: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// path to remove
  public var path: String = String()

  /// allowNotFound doesn't fail the rm if file is not found
  public var allowNotFound: Bool = false

  /// allowWildcard allows filepath.Match wildcards in path
  public var allowWildcard: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_ChownOpt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: Pb_UserOpt {
    get {return _user ?? Pb_UserOpt()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var group: Pb_UserOpt {
    get {return _group ?? Pb_UserOpt()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: Pb_UserOpt? = nil
  fileprivate var _group: Pb_UserOpt? = nil
}

public struct Pb_UserOpt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// changes to this structure must be represented in json.go.
  public var user: Pb_UserOpt.OneOf_User? = nil

  public var byName: Pb_NamedUserOpt {
    get {
      if case .byName(let v)? = user {return v}
      return Pb_NamedUserOpt()
    }
    set {user = .byName(newValue)}
  }

  public var byID: UInt32 {
    get {
      if case .byID(let v)? = user {return v}
      return 0
    }
    set {user = .byID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// changes to this structure must be represented in json.go.
  public enum OneOf_User: Equatable, Sendable {
    case byName(Pb_NamedUserOpt)
    case byID(UInt32)

  }

  public init() {}
}

public struct Pb_NamedUserOpt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var input: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_MergeInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_MergeOp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inputs: [Pb_MergeInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_LowerDiffInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_UpperDiffInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pb_DiffOp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lower: Pb_LowerDiffInput {
    get {return _lower ?? Pb_LowerDiffInput()}
    set {_lower = newValue}
  }
  /// Returns true if `lower` has been explicitly set.
  public var hasLower: Bool {return self._lower != nil}
  /// Clears the value of `lower`. Subsequent reads from it will return its default value.
  public mutating func clearLower() {self._lower = nil}

  public var upper: Pb_UpperDiffInput {
    get {return _upper ?? Pb_UpperDiffInput()}
    set {_upper = newValue}
  }
  /// Returns true if `upper` has been explicitly set.
  public var hasUpper: Bool {return self._upper != nil}
  /// Clears the value of `upper`. Subsequent reads from it will return its default value.
  public mutating func clearUpper() {self._upper = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lower: Pb_LowerDiffInput? = nil
  fileprivate var _upper: Pb_UpperDiffInput? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pb"

extension Pb_NetMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSET\0\u{1}HOST\0\u{1}NONE\0")
}

extension Pb_SecurityMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SANDBOX\0\u{1}INSECURE\0")
}

extension Pb_MountType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BIND\0\u{1}SECRET\0\u{1}SSH\0\u{1}CACHE\0\u{1}TMPFS\0")
}

extension Pb_MountContentCache: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT\0\u{1}ON\0\u{1}OFF\0")
}

extension Pb_CacheSharingOpt: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SHARED\0\u{1}PRIVATE\0\u{1}LOCKED\0")
}

extension Pb_Op: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Op"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}inputs\0\u{1}exec\0\u{1}source\0\u{1}file\0\u{1}build\0\u{1}merge\0\u{1}diff\0\u{2}\u{3}platform\0\u{1}constraints\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try {
        var v: Pb_ExecOp?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .exec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .exec(v)
        }
      }()
      case 3: try {
        var v: Pb_SourceOp?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .source(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .source(v)
        }
      }()
      case 4: try {
        var v: Pb_FileOp?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .file(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .file(v)
        }
      }()
      case 5: try {
        var v: Pb_BuildOp?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .build(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .build(v)
        }
      }()
      case 6: try {
        var v: Pb_MergeOp?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .merge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .merge(v)
        }
      }()
      case 7: try {
        var v: Pb_DiffOp?
        var hadOneofValue = false
        if let current = self.op {
          hadOneofValue = true
          if case .diff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.op = .diff(v)
        }
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._constraints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    switch self.op {
    case .exec?: try {
      guard case .exec(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .source?: try {
      guard case .source(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .file?: try {
      guard case .file(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .build?: try {
      guard case .build(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .merge?: try {
      guard case .merge(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .diff?: try {
      guard case .diff(let v)? = self.op else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try { if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._constraints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Op, rhs: Pb_Op) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.op != rhs.op {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs._constraints != rhs._constraints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Platform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Platform"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Architecture\0\u{1}OS\0\u{1}Variant\0\u{1}OSVersion\0\u{1}OSFeatures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.variant) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osversion) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.osfeatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 1)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 2)
    }
    if !self.variant.isEmpty {
      try visitor.visitSingularStringField(value: self.variant, fieldNumber: 3)
    }
    if !self.osversion.isEmpty {
      try visitor.visitSingularStringField(value: self.osversion, fieldNumber: 4)
    }
    if !self.osfeatures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.osfeatures, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Platform, rhs: Pb_Platform) -> Bool {
    if lhs.architecture != rhs.architecture {return false}
    if lhs.os != rhs.os {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.osversion != rhs.osversion {return false}
    if lhs.osfeatures != rhs.osfeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Input"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}digest\0\u{1}index\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.digest) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.digest.isEmpty {
      try visitor.visitSingularStringField(value: self.digest, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Input, rhs: Pb_Input) -> Bool {
    if lhs.digest != rhs.digest {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ExecOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecOp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}meta\0\u{1}mounts\0\u{1}network\0\u{1}security\0\u{1}secretenv\0\u{1}cdiDevices\0")

  fileprivate class _StorageClass {
    var _meta: Pb_Meta? = nil
    var _mounts: [Pb_Mount] = []
    var _network: Pb_NetMode = .unset
    var _security: Pb_SecurityMode = .sandbox
    var _secretenv: [Pb_SecretEnv] = []
    var _cdiDevices: [Pb_CDIDevice] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _meta = source._meta
      _mounts = source._mounts
      _network = source._network
      _security = source._security
      _secretenv = source._secretenv
      _cdiDevices = source._cdiDevices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._mounts) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._network) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._security) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._secretenv) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._cdiDevices) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._mounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mounts, fieldNumber: 2)
      }
      if _storage._network != .unset {
        try visitor.visitSingularEnumField(value: _storage._network, fieldNumber: 3)
      }
      if _storage._security != .sandbox {
        try visitor.visitSingularEnumField(value: _storage._security, fieldNumber: 4)
      }
      if !_storage._secretenv.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._secretenv, fieldNumber: 5)
      }
      if !_storage._cdiDevices.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cdiDevices, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ExecOp, rhs: Pb_ExecOp) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._security != rhs_storage._security {return false}
        if _storage._secretenv != rhs_storage._secretenv {return false}
        if _storage._cdiDevices != rhs_storage._cdiDevices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Meta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Meta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}args\0\u{1}env\0\u{1}cwd\0\u{1}user\0\u{3}proxy_env\0\u{1}extraHosts\0\u{1}hostname\0\u{2}\u{2}ulimit\0\u{1}cgroupParent\0\u{1}removeMountStubsRecursive\0\u{1}validExitCodes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.env) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cwd) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._proxyEnv) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.extraHosts) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.ulimit) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.cgroupParent) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.removeMountStubsRecursive) }()
      case 12: try { try decoder.decodeRepeatedInt32Field(value: &self.validExitCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 1)
    }
    if !self.env.isEmpty {
      try visitor.visitRepeatedStringField(value: self.env, fieldNumber: 2)
    }
    if !self.cwd.isEmpty {
      try visitor.visitSingularStringField(value: self.cwd, fieldNumber: 3)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 4)
    }
    try { if let v = self._proxyEnv {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.extraHosts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extraHosts, fieldNumber: 6)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 7)
    }
    if !self.ulimit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ulimit, fieldNumber: 9)
    }
    if !self.cgroupParent.isEmpty {
      try visitor.visitSingularStringField(value: self.cgroupParent, fieldNumber: 10)
    }
    if self.removeMountStubsRecursive != false {
      try visitor.visitSingularBoolField(value: self.removeMountStubsRecursive, fieldNumber: 11)
    }
    if !self.validExitCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.validExitCodes, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Meta, rhs: Pb_Meta) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.env != rhs.env {return false}
    if lhs.cwd != rhs.cwd {return false}
    if lhs.user != rhs.user {return false}
    if lhs._proxyEnv != rhs._proxyEnv {return false}
    if lhs.extraHosts != rhs.extraHosts {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.ulimit != rhs.ulimit {return false}
    if lhs.cgroupParent != rhs.cgroupParent {return false}
    if lhs.removeMountStubsRecursive != rhs.removeMountStubsRecursive {return false}
    if lhs.validExitCodes != rhs.validExitCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_HostIP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HostIP"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Host\0\u{1}IP\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_HostIP, rhs: Pb_HostIP) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Ulimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ulimit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Name\0\u{1}Soft\0\u{1}Hard\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.soft) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.hard) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.soft != 0 {
      try visitor.visitSingularInt64Field(value: self.soft, fieldNumber: 2)
    }
    if self.hard != 0 {
      try visitor.visitSingularInt64Field(value: self.hard, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Ulimit, rhs: Pb_Ulimit) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.soft != rhs.soft {return false}
    if lhs.hard != rhs.hard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SecretEnv: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SecretEnv"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}name\0\u{1}optional\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.optional) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.optional != false {
      try visitor.visitSingularBoolField(value: self.optional, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_SecretEnv, rhs: Pb_SecretEnv) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.optional != rhs.optional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CDIDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CDIDevice"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}optional\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.optional) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.optional != false {
      try visitor.visitSingularBoolField(value: self.optional, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_CDIDevice, rhs: Pb_CDIDevice) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.optional != rhs.optional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Mount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mount"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0\u{1}selector\0\u{1}dest\0\u{1}output\0\u{1}readonly\0\u{1}mountType\0\u{2}\u{d}TmpfsOpt\0\u{1}cacheOpt\0\u{1}secretOpt\0\u{1}SSHOpt\0\u{1}resultID\0\u{1}contentCache\0")

  fileprivate class _StorageClass {
    var _input: Int64 = 0
    var _selector: String = String()
    var _dest: String = String()
    var _output: Int64 = 0
    var _readonly: Bool = false
    var _mountType: Pb_MountType = .bind
    var _tmpfsOpt: Pb_TmpfsOpt? = nil
    var _cacheOpt: Pb_CacheOpt? = nil
    var _secretOpt: Pb_SecretOpt? = nil
    var _sshopt: Pb_SSHOpt? = nil
    var _resultID: String = String()
    var _contentCache: Pb_MountContentCache = .default

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _input = source._input
      _selector = source._selector
      _dest = source._dest
      _output = source._output
      _readonly = source._readonly
      _mountType = source._mountType
      _tmpfsOpt = source._tmpfsOpt
      _cacheOpt = source._cacheOpt
      _secretOpt = source._secretOpt
      _sshopt = source._sshopt
      _resultID = source._resultID
      _contentCache = source._contentCache
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._input) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._selector) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._dest) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._output) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._readonly) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._mountType) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._tmpfsOpt) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._cacheOpt) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._secretOpt) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._sshopt) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._resultID) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._contentCache) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._input != 0 {
        try visitor.visitSingularInt64Field(value: _storage._input, fieldNumber: 1)
      }
      if !_storage._selector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._selector, fieldNumber: 2)
      }
      if !_storage._dest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dest, fieldNumber: 3)
      }
      if _storage._output != 0 {
        try visitor.visitSingularInt64Field(value: _storage._output, fieldNumber: 4)
      }
      if _storage._readonly != false {
        try visitor.visitSingularBoolField(value: _storage._readonly, fieldNumber: 5)
      }
      if _storage._mountType != .bind {
        try visitor.visitSingularEnumField(value: _storage._mountType, fieldNumber: 6)
      }
      try { if let v = _storage._tmpfsOpt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._cacheOpt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._secretOpt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._sshopt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._resultID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resultID, fieldNumber: 23)
      }
      if _storage._contentCache != .default {
        try visitor.visitSingularEnumField(value: _storage._contentCache, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Mount, rhs: Pb_Mount) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._input != rhs_storage._input {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._dest != rhs_storage._dest {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._readonly != rhs_storage._readonly {return false}
        if _storage._mountType != rhs_storage._mountType {return false}
        if _storage._tmpfsOpt != rhs_storage._tmpfsOpt {return false}
        if _storage._cacheOpt != rhs_storage._cacheOpt {return false}
        if _storage._secretOpt != rhs_storage._secretOpt {return false}
        if _storage._sshopt != rhs_storage._sshopt {return false}
        if _storage._resultID != rhs_storage._resultID {return false}
        if _storage._contentCache != rhs_storage._contentCache {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_TmpfsOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TmpfsOpt"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}size\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_TmpfsOpt, rhs: Pb_TmpfsOpt) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CacheOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CacheOpt"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}sharing\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sharing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.sharing != .shared {
      try visitor.visitSingularEnumField(value: self.sharing, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_CacheOpt, rhs: Pb_CacheOpt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.sharing != rhs.sharing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SecretOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SecretOpt"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}uid\0\u{1}gid\0\u{1}mode\0\u{1}optional\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.gid) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.optional) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 2)
    }
    if self.gid != 0 {
      try visitor.visitSingularUInt32Field(value: self.gid, fieldNumber: 3)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 4)
    }
    if self.optional != false {
      try visitor.visitSingularBoolField(value: self.optional, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_SecretOpt, rhs: Pb_SecretOpt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.optional != rhs.optional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SSHOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SSHOpt"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}uid\0\u{1}gid\0\u{1}mode\0\u{1}optional\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.gid) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.optional) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 2)
    }
    if self.gid != 0 {
      try visitor.visitSingularUInt32Field(value: self.gid, fieldNumber: 3)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 4)
    }
    if self.optional != false {
      try visitor.visitSingularBoolField(value: self.optional, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_SSHOpt, rhs: Pb_SSHOpt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.optional != rhs.optional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SourceOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceOp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{1}attrs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attrs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if !self.attrs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attrs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_SourceOp, rhs: Pb_SourceOp) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.attrs != rhs.attrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_BuildOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildOp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}builder\0\u{1}inputs\0\u{1}def\0\u{1}attrs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.builder) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_BuildInput>.self, value: &self.inputs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._def) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attrs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.builder != 0 {
      try visitor.visitSingularInt64Field(value: self.builder, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_BuildInput>.self, value: self.inputs, fieldNumber: 2)
    }
    try { if let v = self._def {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.attrs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attrs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_BuildOp, rhs: Pb_BuildOp) -> Bool {
    if lhs.builder != rhs.builder {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs._def != rhs._def {return false}
    if lhs.attrs != rhs.attrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_BuildInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.input != 0 {
      try visitor.visitSingularInt64Field(value: self.input, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_BuildInput, rhs: Pb_BuildInput) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_OpMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}ignore_cache\0\u{1}description\0\u{4}\u{2}export_cache\0\u{1}caps\0\u{3}progress_group\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ignoreCache) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._exportCache) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: &self.caps) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._progressGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.ignoreCache != false {
      try visitor.visitSingularBoolField(value: self.ignoreCache, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._exportCache {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.caps.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: self.caps, fieldNumber: 5)
    }
    try { if let v = self._progressGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_OpMetadata, rhs: Pb_OpMetadata) -> Bool {
    if lhs.ignoreCache != rhs.ignoreCache {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._exportCache != rhs._exportCache {return false}
    if lhs.caps != rhs.caps {return false}
    if lhs._progressGroup != rhs._progressGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Source"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}locations\0\u{1}infos\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_Locations>.self, value: &self.locations) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_Locations>.self, value: self.locations, fieldNumber: 1)
    }
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Source, rhs: Pb_Source) -> Bool {
    if lhs.locations != rhs.locations {return false}
    if lhs.infos != rhs.infos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Locations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Locations"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}locations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.locations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Locations, rhs: Pb_Locations) -> Bool {
    if lhs.locations != rhs.locations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SourceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}filename\0\u{1}data\0\u{1}definition\0\u{1}language\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._definition) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try { if let v = self._definition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_SourceInfo, rhs: Pb_SourceInfo) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.data != rhs.data {return false}
    if lhs._definition != rhs._definition {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sourceIndex\0\u{1}ranges\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sourceIndex) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceIndex, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Location, rhs: Pb_Location) -> Bool {
    if lhs.sourceIndex != rhs.sourceIndex {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Range"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Range, rhs: Pb_Range) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Position"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}line\0\u{1}character\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.line) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.character) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.line != 0 {
      try visitor.visitSingularInt32Field(value: self.line, fieldNumber: 1)
    }
    if self.character != 0 {
      try visitor.visitSingularInt32Field(value: self.character, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Position, rhs: Pb_Position) -> Bool {
    if lhs.line != rhs.line {return false}
    if lhs.character != rhs.character {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ExportCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportCache"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ExportCache, rhs: Pb_ExportCache) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ProgressGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProgressGroup"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}weak\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.weak) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.weak != false {
      try visitor.visitSingularBoolField(value: self.weak, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ProgressGroup, rhs: Pb_ProgressGroup) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.weak != rhs.weak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ProxyEnv: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProxyEnv"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}http_proxy\0\u{3}https_proxy\0\u{3}ftp_proxy\0\u{3}no_proxy\0\u{3}all_proxy\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.httpProxy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.httpsProxy) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ftpProxy) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.noProxy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.allProxy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.httpProxy.isEmpty {
      try visitor.visitSingularStringField(value: self.httpProxy, fieldNumber: 1)
    }
    if !self.httpsProxy.isEmpty {
      try visitor.visitSingularStringField(value: self.httpsProxy, fieldNumber: 2)
    }
    if !self.ftpProxy.isEmpty {
      try visitor.visitSingularStringField(value: self.ftpProxy, fieldNumber: 3)
    }
    if !self.noProxy.isEmpty {
      try visitor.visitSingularStringField(value: self.noProxy, fieldNumber: 4)
    }
    if !self.allProxy.isEmpty {
      try visitor.visitSingularStringField(value: self.allProxy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ProxyEnv, rhs: Pb_ProxyEnv) -> Bool {
    if lhs.httpProxy != rhs.httpProxy {return false}
    if lhs.httpsProxy != rhs.httpsProxy {return false}
    if lhs.ftpProxy != rhs.ftpProxy {return false}
    if lhs.noProxy != rhs.noProxy {return false}
    if lhs.allProxy != rhs.allProxy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_WorkerConstraints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerConstraints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_WorkerConstraints, rhs: Pb_WorkerConstraints) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Definition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Definition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}def\0\u{1}metadata\0\u{1}Source\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.def) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_OpMetadata>.self, value: &self.metadata) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.def.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.def, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_OpMetadata>.self, value: self.metadata, fieldNumber: 2)
    }
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_Definition, rhs: Pb_Definition) -> Bool {
    if lhs.def != rhs.def {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_FileOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileOp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}actions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_FileOp, rhs: Pb_FileOp) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_FileAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0\u{1}secondaryInput\0\u{1}output\0\u{1}copy\0\u{1}mkfile\0\u{1}mkdir\0\u{1}rm\0\u{1}symlink\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.input) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.secondaryInput) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.output) }()
      case 4: try {
        var v: Pb_FileActionCopy?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .copy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .copy(v)
        }
      }()
      case 5: try {
        var v: Pb_FileActionMkFile?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .mkfile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .mkfile(v)
        }
      }()
      case 6: try {
        var v: Pb_FileActionMkDir?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .mkdir(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .mkdir(v)
        }
      }()
      case 7: try {
        var v: Pb_FileActionRm?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .rm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .rm(v)
        }
      }()
      case 8: try {
        var v: Pb_FileActionSymlink?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .symlink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .symlink(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.input != 0 {
      try visitor.visitSingularInt64Field(value: self.input, fieldNumber: 1)
    }
    if self.secondaryInput != 0 {
      try visitor.visitSingularInt64Field(value: self.secondaryInput, fieldNumber: 2)
    }
    if self.output != 0 {
      try visitor.visitSingularInt64Field(value: self.output, fieldNumber: 3)
    }
    switch self.action {
    case .copy?: try {
      guard case .copy(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .mkfile?: try {
      guard case .mkfile(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .mkdir?: try {
      guard case .mkdir(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .rm?: try {
      guard case .rm(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .symlink?: try {
      guard case .symlink(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_FileAction, rhs: Pb_FileAction) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.secondaryInput != rhs.secondaryInput {return false}
    if lhs.output != rhs.output {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_FileActionCopy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileActionCopy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}src\0\u{1}dest\0\u{1}owner\0\u{1}mode\0\u{1}followSymlink\0\u{1}dirCopyContents\0\u{1}attemptUnpackDockerCompatibility\0\u{1}createDestPath\0\u{1}allowWildcard\0\u{1}allowEmptyWildcard\0\u{1}timestamp\0\u{3}include_patterns\0\u{3}exclude_patterns\0\u{1}alwaysReplaceExistingDestPaths\0\u{1}modeStr\0\u{3}required_paths\0")

  fileprivate class _StorageClass {
    var _src: String = String()
    var _dest: String = String()
    var _owner: Pb_ChownOpt? = nil
    var _mode: Int32 = 0
    var _followSymlink: Bool = false
    var _dirCopyContents: Bool = false
    var _attemptUnpackDockerCompatibility: Bool = false
    var _createDestPath: Bool = false
    var _allowWildcard: Bool = false
    var _allowEmptyWildcard: Bool = false
    var _timestamp: Int64 = 0
    var _includePatterns: [String] = []
    var _excludePatterns: [String] = []
    var _alwaysReplaceExistingDestPaths: Bool = false
    var _modeStr: String = String()
    var _requiredPaths: [String] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _src = source._src
      _dest = source._dest
      _owner = source._owner
      _mode = source._mode
      _followSymlink = source._followSymlink
      _dirCopyContents = source._dirCopyContents
      _attemptUnpackDockerCompatibility = source._attemptUnpackDockerCompatibility
      _createDestPath = source._createDestPath
      _allowWildcard = source._allowWildcard
      _allowEmptyWildcard = source._allowEmptyWildcard
      _timestamp = source._timestamp
      _includePatterns = source._includePatterns
      _excludePatterns = source._excludePatterns
      _alwaysReplaceExistingDestPaths = source._alwaysReplaceExistingDestPaths
      _modeStr = source._modeStr
      _requiredPaths = source._requiredPaths
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._src) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._dest) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._mode) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._followSymlink) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._dirCopyContents) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._attemptUnpackDockerCompatibility) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._createDestPath) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._allowWildcard) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._allowEmptyWildcard) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._includePatterns) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._excludePatterns) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._alwaysReplaceExistingDestPaths) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._modeStr) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._requiredPaths) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._src.isEmpty {
        try visitor.visitSingularStringField(value: _storage._src, fieldNumber: 1)
      }
      if !_storage._dest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dest, fieldNumber: 2)
      }
      try { if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._mode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mode, fieldNumber: 4)
      }
      if _storage._followSymlink != false {
        try visitor.visitSingularBoolField(value: _storage._followSymlink, fieldNumber: 5)
      }
      if _storage._dirCopyContents != false {
        try visitor.visitSingularBoolField(value: _storage._dirCopyContents, fieldNumber: 6)
      }
      if _storage._attemptUnpackDockerCompatibility != false {
        try visitor.visitSingularBoolField(value: _storage._attemptUnpackDockerCompatibility, fieldNumber: 7)
      }
      if _storage._createDestPath != false {
        try visitor.visitSingularBoolField(value: _storage._createDestPath, fieldNumber: 8)
      }
      if _storage._allowWildcard != false {
        try visitor.visitSingularBoolField(value: _storage._allowWildcard, fieldNumber: 9)
      }
      if _storage._allowEmptyWildcard != false {
        try visitor.visitSingularBoolField(value: _storage._allowEmptyWildcard, fieldNumber: 10)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 11)
      }
      if !_storage._includePatterns.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._includePatterns, fieldNumber: 12)
      }
      if !_storage._excludePatterns.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._excludePatterns, fieldNumber: 13)
      }
      if _storage._alwaysReplaceExistingDestPaths != false {
        try visitor.visitSingularBoolField(value: _storage._alwaysReplaceExistingDestPaths, fieldNumber: 14)
      }
      if !_storage._modeStr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modeStr, fieldNumber: 15)
      }
      if !_storage._requiredPaths.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requiredPaths, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_FileActionCopy, rhs: Pb_FileActionCopy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._src != rhs_storage._src {return false}
        if _storage._dest != rhs_storage._dest {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._followSymlink != rhs_storage._followSymlink {return false}
        if _storage._dirCopyContents != rhs_storage._dirCopyContents {return false}
        if _storage._attemptUnpackDockerCompatibility != rhs_storage._attemptUnpackDockerCompatibility {return false}
        if _storage._createDestPath != rhs_storage._createDestPath {return false}
        if _storage._allowWildcard != rhs_storage._allowWildcard {return false}
        if _storage._allowEmptyWildcard != rhs_storage._allowEmptyWildcard {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._includePatterns != rhs_storage._includePatterns {return false}
        if _storage._excludePatterns != rhs_storage._excludePatterns {return false}
        if _storage._alwaysReplaceExistingDestPaths != rhs_storage._alwaysReplaceExistingDestPaths {return false}
        if _storage._modeStr != rhs_storage._modeStr {return false}
        if _storage._requiredPaths != rhs_storage._requiredPaths {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_FileActionMkFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileActionMkFile"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0\u{1}mode\0\u{1}data\0\u{1}owner\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.mode != 0 {
      try visitor.visitSingularInt32Field(value: self.mode, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_FileActionMkFile, rhs: Pb_FileActionMkFile) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.data != rhs.data {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_FileActionSymlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileActionSymlink"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}oldpath\0\u{1}newpath\0\u{1}owner\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldpath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newpath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.oldpath.isEmpty {
      try visitor.visitSingularStringField(value: self.oldpath, fieldNumber: 1)
    }
    if !self.newpath.isEmpty {
      try visitor.visitSingularStringField(value: self.newpath, fieldNumber: 2)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_FileActionSymlink, rhs: Pb_FileActionSymlink) -> Bool {
    if lhs.oldpath != rhs.oldpath {return false}
    if lhs.newpath != rhs.newpath {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_FileActionMkDir: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileActionMkDir"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0\u{1}mode\0\u{1}makeParents\0\u{1}owner\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.makeParents) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.mode != 0 {
      try visitor.visitSingularInt32Field(value: self.mode, fieldNumber: 2)
    }
    if self.makeParents != false {
      try visitor.visitSingularBoolField(value: self.makeParents, fieldNumber: 3)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_FileActionMkDir, rhs: Pb_FileActionMkDir) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.makeParents != rhs.makeParents {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_FileActionRm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileActionRm"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0\u{1}allowNotFound\0\u{1}allowWildcard\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowNotFound) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowWildcard) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.allowNotFound != false {
      try visitor.visitSingularBoolField(value: self.allowNotFound, fieldNumber: 2)
    }
    if self.allowWildcard != false {
      try visitor.visitSingularBoolField(value: self.allowWildcard, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_FileActionRm, rhs: Pb_FileActionRm) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.allowNotFound != rhs.allowNotFound {return false}
    if lhs.allowWildcard != rhs.allowWildcard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_ChownOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChownOpt"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}user\0\u{1}group\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_ChownOpt, rhs: Pb_ChownOpt) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_UserOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserOpt"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}byName\0\u{1}byID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Pb_NamedUserOpt?
        var hadOneofValue = false
        if let current = self.user {
          hadOneofValue = true
          if case .byName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.user = .byName(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.user != nil {try decoder.handleConflictingOneOf()}
          self.user = .byID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.user {
    case .byName?: try {
      guard case .byName(let v)? = self.user else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .byID?: try {
      guard case .byID(let v)? = self.user else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_UserOpt, rhs: Pb_UserOpt) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_NamedUserOpt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedUserOpt"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}input\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.input != 0 {
      try visitor.visitSingularInt64Field(value: self.input, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_NamedUserOpt, rhs: Pb_NamedUserOpt) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MergeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.input != 0 {
      try visitor.visitSingularInt64Field(value: self.input, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MergeInput, rhs: Pb_MergeInput) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MergeOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeOp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}inputs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_MergeOp, rhs: Pb_MergeOp) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_LowerDiffInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LowerDiffInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.input != 0 {
      try visitor.visitSingularInt64Field(value: self.input, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_LowerDiffInput, rhs: Pb_LowerDiffInput) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_UpperDiffInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpperDiffInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.input != 0 {
      try visitor.visitSingularInt64Field(value: self.input, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_UpperDiffInput, rhs: Pb_UpperDiffInput) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_DiffOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiffOp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lower\0\u{1}upper\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lower) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._upper) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lower {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._upper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pb_DiffOp, rhs: Pb_DiffOp) -> Bool {
    if lhs._lower != rhs._lower {return false}
    if lhs._upper != rhs._upper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
