// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: github.com/moby/buildkit/api/services/control/control.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Moby_Buildkit_V1_BuildHistoryEventType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case started // = 0
  case complete // = 1
  case deleted // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .started
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .started
    case 1: self = .complete
    case 2: self = .deleted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .started: return 0
    case .complete: return 1
    case .deleted: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Moby_Buildkit_V1_BuildHistoryEventType] = [
    .started,
    .complete,
    .deleted,
  ]

}

public struct Moby_Buildkit_V1_PruneRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filter: [String] = []

  public var all: Bool = false

  public var keepDuration: Int64 = 0

  public var reservedSpace: Int64 = 0

  public var maxUsedSpace: Int64 = 0

  public var minFreeSpace: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_DiskUsageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filter: [String] = []

  public var ageLimit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_DiskUsageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var record: [Moby_Buildkit_V1_UsageRecord] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_UsageRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var mutable: Bool = false

  public var inUse: Bool = false

  public var size: Int64 = 0

  /// NOTE: This field was marked as deprecated in the .proto file.
  public var parent: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var lastUsedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUsedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUsedAt = newValue}
  }
  /// Returns true if `lastUsedAt` has been explicitly set.
  public var hasLastUsedAt: Bool {return self._lastUsedAt != nil}
  /// Clears the value of `lastUsedAt`. Subsequent reads from it will return its default value.
  public mutating func clearLastUsedAt() {self._lastUsedAt = nil}

  public var usageCount: Int64 = 0

  public var description_p: String = String()

  public var recordType: String = String()

  public var shared: Bool = false

  public var parents: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastUsedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Moby_Buildkit_V1_SolveRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: String {
    get {return _storage._ref}
    set {_uniqueStorage()._ref = newValue}
  }

  public var definition: Pb_Definition {
    get {return _storage._definition ?? Pb_Definition()}
    set {_uniqueStorage()._definition = newValue}
  }
  /// Returns true if `definition` has been explicitly set.
  public var hasDefinition: Bool {return _storage._definition != nil}
  /// Clears the value of `definition`. Subsequent reads from it will return its default value.
  public mutating func clearDefinition() {_uniqueStorage()._definition = nil}

  /// ExporterDeprecated and ExporterAttrsDeprecated are deprecated in favor
  /// of the new Exporters. If these fields are set, then they will be
  /// appended to the Exporters field if Exporters was not explicitly set.
  public var exporterDeprecated: String {
    get {return _storage._exporterDeprecated}
    set {_uniqueStorage()._exporterDeprecated = newValue}
  }

  public var exporterAttrsDeprecated: Dictionary<String,String> {
    get {return _storage._exporterAttrsDeprecated}
    set {_uniqueStorage()._exporterAttrsDeprecated = newValue}
  }

  public var session: String {
    get {return _storage._session}
    set {_uniqueStorage()._session = newValue}
  }

  public var frontend: String {
    get {return _storage._frontend}
    set {_uniqueStorage()._frontend = newValue}
  }

  public var frontendAttrs: Dictionary<String,String> {
    get {return _storage._frontendAttrs}
    set {_uniqueStorage()._frontendAttrs = newValue}
  }

  public var cache: Moby_Buildkit_V1_CacheOptions {
    get {return _storage._cache ?? Moby_Buildkit_V1_CacheOptions()}
    set {_uniqueStorage()._cache = newValue}
  }
  /// Returns true if `cache` has been explicitly set.
  public var hasCache: Bool {return _storage._cache != nil}
  /// Clears the value of `cache`. Subsequent reads from it will return its default value.
  public mutating func clearCache() {_uniqueStorage()._cache = nil}

  public var entitlements: [String] {
    get {return _storage._entitlements}
    set {_uniqueStorage()._entitlements = newValue}
  }

  public var frontendInputs: Dictionary<String,Pb_Definition> {
    get {return _storage._frontendInputs}
    set {_uniqueStorage()._frontendInputs = newValue}
  }

  /// Internal builds are not recorded in build history
  public var `internal`: Bool {
    get {return _storage._internal}
    set {_uniqueStorage()._internal = newValue}
  }

  public var sourcePolicy: Moby_Buildkit_V1_Sourcepolicy_Policy {
    get {return _storage._sourcePolicy ?? Moby_Buildkit_V1_Sourcepolicy_Policy()}
    set {_uniqueStorage()._sourcePolicy = newValue}
  }
  /// Returns true if `sourcePolicy` has been explicitly set.
  public var hasSourcePolicy: Bool {return _storage._sourcePolicy != nil}
  /// Clears the value of `sourcePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearSourcePolicy() {_uniqueStorage()._sourcePolicy = nil}

  public var exporters: [Moby_Buildkit_V1_Exporter] {
    get {return _storage._exporters}
    set {_uniqueStorage()._exporters = newValue}
  }

  public var enableSessionExporter: Bool {
    get {return _storage._enableSessionExporter}
    set {_uniqueStorage()._enableSessionExporter = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Moby_Buildkit_V1_CacheOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ExportRefDeprecated is deprecated in favor or the new Exports since BuildKit v0.4.0.
  /// When ExportRefDeprecated is set, the solver appends
  /// {.Type = "registry", .Attrs = ExportAttrs.add("ref", ExportRef)}
  /// to Exports for compatibility. (planned to be removed)
  public var exportRefDeprecated: String = String()

  /// ImportRefsDeprecated is deprecated in favor or the new Imports since BuildKit v0.4.0.
  /// When ImportRefsDeprecated is set, the solver appends
  /// {.Type = "registry", .Attrs = {"ref": importRef}}
  /// for each of the ImportRefs entry to Imports for compatibility. (planned to be removed)
  public var importRefsDeprecated: [String] = []

  /// ExportAttrsDeprecated is deprecated since BuildKit v0.4.0.
  /// See the description of ExportRefDeprecated.
  public var exportAttrsDeprecated: Dictionary<String,String> = [:]

  /// Exports was introduced in BuildKit v0.4.0.
  public var exports: [Moby_Buildkit_V1_CacheOptionsEntry] = []

  /// Imports was introduced in BuildKit v0.4.0.
  public var imports: [Moby_Buildkit_V1_CacheOptionsEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_CacheOptionsEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is like "registry" or "local"
  public var type: String = String()

  /// Attrs are like mode=(min,max), ref=example.com:5000/foo/bar .
  /// See cache importer/exporter implementations' documentation.
  public var attrs: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_SolveResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exporterResponse: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_StatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_StatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vertexes: [Moby_Buildkit_V1_Vertex] = []

  public var statuses: [Moby_Buildkit_V1_VertexStatus] = []

  public var logs: [Moby_Buildkit_V1_VertexLog] = []

  public var warnings: [Moby_Buildkit_V1_VertexWarning] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_Vertex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var digest: String = String()

  public var inputs: [String] = []

  public var name: String = String()

  public var cached: Bool = false

  public var started: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _started ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_started = newValue}
  }
  /// Returns true if `started` has been explicitly set.
  public var hasStarted: Bool {return self._started != nil}
  /// Clears the value of `started`. Subsequent reads from it will return its default value.
  public mutating func clearStarted() {self._started = nil}

  public var completed: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _completed ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_completed = newValue}
  }
  /// Returns true if `completed` has been explicitly set.
  public var hasCompleted: Bool {return self._completed != nil}
  /// Clears the value of `completed`. Subsequent reads from it will return its default value.
  public mutating func clearCompleted() {self._completed = nil}

  /// typed errors?
  public var error: String = String()

  public var progressGroup: Pb_ProgressGroup {
    get {return _progressGroup ?? Pb_ProgressGroup()}
    set {_progressGroup = newValue}
  }
  /// Returns true if `progressGroup` has been explicitly set.
  public var hasProgressGroup: Bool {return self._progressGroup != nil}
  /// Clears the value of `progressGroup`. Subsequent reads from it will return its default value.
  public mutating func clearProgressGroup() {self._progressGroup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _started: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _completed: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _progressGroup: Pb_ProgressGroup? = nil
}

public struct Moby_Buildkit_V1_VertexStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var vertex: String = String()

  public var name: String = String()

  public var current: Int64 = 0

  public var total: Int64 = 0

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var started: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _started ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_started = newValue}
  }
  /// Returns true if `started` has been explicitly set.
  public var hasStarted: Bool {return self._started != nil}
  /// Clears the value of `started`. Subsequent reads from it will return its default value.
  public mutating func clearStarted() {self._started = nil}

  public var completed: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _completed ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_completed = newValue}
  }
  /// Returns true if `completed` has been explicitly set.
  public var hasCompleted: Bool {return self._completed != nil}
  /// Clears the value of `completed`. Subsequent reads from it will return its default value.
  public mutating func clearCompleted() {self._completed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _started: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _completed: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Moby_Buildkit_V1_VertexLog: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vertex: String = String()

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var stream: Int64 = 0

  public var msg: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Moby_Buildkit_V1_VertexWarning: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vertex: String = String()

  public var level: Int64 = 0

  public var short: Data = Data()

  public var detail: [Data] = []

  public var url: String = String()

  public var info: Pb_SourceInfo {
    get {return _info ?? Pb_SourceInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var ranges: [Pb_Range] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Pb_SourceInfo? = nil
}

public struct Moby_Buildkit_V1_BytesMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_ListWorkersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// containerd style
  public var filter: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_ListWorkersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var record: [Moby_Buildkit_V1_Types_WorkerRecord] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_InfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_InfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var buildkitVersion: Moby_Buildkit_V1_Types_BuildkitVersion {
    get {return _buildkitVersion ?? Moby_Buildkit_V1_Types_BuildkitVersion()}
    set {_buildkitVersion = newValue}
  }
  /// Returns true if `buildkitVersion` has been explicitly set.
  public var hasBuildkitVersion: Bool {return self._buildkitVersion != nil}
  /// Clears the value of `buildkitVersion`. Subsequent reads from it will return its default value.
  public mutating func clearBuildkitVersion() {self._buildkitVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _buildkitVersion: Moby_Buildkit_V1_Types_BuildkitVersion? = nil
}

public struct Moby_Buildkit_V1_BuildHistoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeOnly: Bool = false

  public var ref: String = String()

  public var earlyExit: Bool = false

  public var filter: [String] = []

  public var limit: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_BuildHistoryEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Moby_Buildkit_V1_BuildHistoryEventType = .started

  public var record: Moby_Buildkit_V1_BuildHistoryRecord {
    get {return _record ?? Moby_Buildkit_V1_BuildHistoryRecord()}
    set {_record = newValue}
  }
  /// Returns true if `record` has been explicitly set.
  public var hasRecord: Bool {return self._record != nil}
  /// Clears the value of `record`. Subsequent reads from it will return its default value.
  public mutating func clearRecord() {self._record = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _record: Moby_Buildkit_V1_BuildHistoryRecord? = nil
}

public struct Moby_Buildkit_V1_BuildHistoryRecord: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: String {
    get {return _storage._ref}
    set {_uniqueStorage()._ref = newValue}
  }

  public var frontend: String {
    get {return _storage._frontend}
    set {_uniqueStorage()._frontend = newValue}
  }

  public var frontendAttrs: Dictionary<String,String> {
    get {return _storage._frontendAttrs}
    set {_uniqueStorage()._frontendAttrs = newValue}
  }

  public var exporters: [Moby_Buildkit_V1_Exporter] {
    get {return _storage._exporters}
    set {_uniqueStorage()._exporters = newValue}
  }

  public var error: Google_Rpc_Status {
    get {return _storage._error ?? Google_Rpc_Status()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {_uniqueStorage()._error = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var completedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._completedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  public var hasCompletedAt: Bool {return _storage._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  public mutating func clearCompletedAt() {_uniqueStorage()._completedAt = nil}

  public var logs: Moby_Buildkit_V1_Descriptor {
    get {return _storage._logs ?? Moby_Buildkit_V1_Descriptor()}
    set {_uniqueStorage()._logs = newValue}
  }
  /// Returns true if `logs` has been explicitly set.
  public var hasLogs: Bool {return _storage._logs != nil}
  /// Clears the value of `logs`. Subsequent reads from it will return its default value.
  public mutating func clearLogs() {_uniqueStorage()._logs = nil}

  public var exporterResponse: Dictionary<String,String> {
    get {return _storage._exporterResponse}
    set {_uniqueStorage()._exporterResponse = newValue}
  }

  public var result: Moby_Buildkit_V1_BuildResultInfo {
    get {return _storage._result ?? Moby_Buildkit_V1_BuildResultInfo()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {_uniqueStorage()._result = nil}

  public var results: Dictionary<String,Moby_Buildkit_V1_BuildResultInfo> {
    get {return _storage._results}
    set {_uniqueStorage()._results = newValue}
  }

  public var generation: Int32 {
    get {return _storage._generation}
    set {_uniqueStorage()._generation = newValue}
  }

  public var trace: Moby_Buildkit_V1_Descriptor {
    get {return _storage._trace ?? Moby_Buildkit_V1_Descriptor()}
    set {_uniqueStorage()._trace = newValue}
  }
  /// Returns true if `trace` has been explicitly set.
  public var hasTrace: Bool {return _storage._trace != nil}
  /// Clears the value of `trace`. Subsequent reads from it will return its default value.
  public mutating func clearTrace() {_uniqueStorage()._trace = nil}

  public var pinned: Bool {
    get {return _storage._pinned}
    set {_uniqueStorage()._pinned = newValue}
  }

  public var numCachedSteps: Int32 {
    get {return _storage._numCachedSteps}
    set {_uniqueStorage()._numCachedSteps = newValue}
  }

  public var numTotalSteps: Int32 {
    get {return _storage._numTotalSteps}
    set {_uniqueStorage()._numTotalSteps = newValue}
  }

  public var numCompletedSteps: Int32 {
    get {return _storage._numCompletedSteps}
    set {_uniqueStorage()._numCompletedSteps = newValue}
  }

  public var externalError: Moby_Buildkit_V1_Descriptor {
    get {return _storage._externalError ?? Moby_Buildkit_V1_Descriptor()}
    set {_uniqueStorage()._externalError = newValue}
  }
  /// Returns true if `externalError` has been explicitly set.
  public var hasExternalError: Bool {return _storage._externalError != nil}
  /// Clears the value of `externalError`. Subsequent reads from it will return its default value.
  public mutating func clearExternalError() {_uniqueStorage()._externalError = nil}

  /// TODO: tags
  /// TODO: unclipped logs
  public var numWarnings: Int32 {
    get {return _storage._numWarnings}
    set {_uniqueStorage()._numWarnings = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Moby_Buildkit_V1_UpdateBuildHistoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: String = String()

  public var pinned: Bool = false

  public var delete: Bool = false

  public var finalize: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_UpdateBuildHistoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_Descriptor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mediaType: String = String()

  public var digest: String = String()

  public var size: Int64 = 0

  public var annotations: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Moby_Buildkit_V1_BuildResultInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resultDeprecated: Moby_Buildkit_V1_Descriptor {
    get {return _resultDeprecated ?? Moby_Buildkit_V1_Descriptor()}
    set {_resultDeprecated = newValue}
  }
  /// Returns true if `resultDeprecated` has been explicitly set.
  public var hasResultDeprecated: Bool {return self._resultDeprecated != nil}
  /// Clears the value of `resultDeprecated`. Subsequent reads from it will return its default value.
  public mutating func clearResultDeprecated() {self._resultDeprecated = nil}

  public var attestations: [Moby_Buildkit_V1_Descriptor] = []

  public var results: Dictionary<Int64,Moby_Buildkit_V1_Descriptor> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resultDeprecated: Moby_Buildkit_V1_Descriptor? = nil
}

/// Exporter describes the output exporter
public struct Moby_Buildkit_V1_Exporter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type identifies the exporter
  public var type: String = String()

  /// Attrs specifies exporter configuration
  public var attrs: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "moby.buildkit.v1"

extension Moby_Buildkit_V1_BuildHistoryEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STARTED\0\u{1}COMPLETE\0\u{1}DELETED\0")
}

extension Moby_Buildkit_V1_PruneRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PruneRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}filter\0\u{1}all\0\u{1}keepDuration\0\u{1}reservedSpace\0\u{1}maxUsedSpace\0\u{1}minFreeSpace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.filter) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.all) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.keepDuration) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.reservedSpace) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.maxUsedSpace) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.minFreeSpace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filter, fieldNumber: 1)
    }
    if self.all != false {
      try visitor.visitSingularBoolField(value: self.all, fieldNumber: 2)
    }
    if self.keepDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.keepDuration, fieldNumber: 3)
    }
    if self.reservedSpace != 0 {
      try visitor.visitSingularInt64Field(value: self.reservedSpace, fieldNumber: 4)
    }
    if self.maxUsedSpace != 0 {
      try visitor.visitSingularInt64Field(value: self.maxUsedSpace, fieldNumber: 5)
    }
    if self.minFreeSpace != 0 {
      try visitor.visitSingularInt64Field(value: self.minFreeSpace, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_PruneRequest, rhs: Moby_Buildkit_V1_PruneRequest) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.all != rhs.all {return false}
    if lhs.keepDuration != rhs.keepDuration {return false}
    if lhs.reservedSpace != rhs.reservedSpace {return false}
    if lhs.maxUsedSpace != rhs.maxUsedSpace {return false}
    if lhs.minFreeSpace != rhs.minFreeSpace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_DiskUsageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiskUsageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}filter\0\u{1}ageLimit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.filter) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ageLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filter, fieldNumber: 1)
    }
    if self.ageLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.ageLimit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_DiskUsageRequest, rhs: Moby_Buildkit_V1_DiskUsageRequest) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.ageLimit != rhs.ageLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_DiskUsageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiskUsageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}record\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.record) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.record.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.record, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_DiskUsageResponse, rhs: Moby_Buildkit_V1_DiskUsageResponse) -> Bool {
    if lhs.record != rhs.record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_UsageRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsageRecord"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}Mutable\0\u{1}InUse\0\u{1}Size\0\u{1}Parent\0\u{1}CreatedAt\0\u{1}LastUsedAt\0\u{1}UsageCount\0\u{1}Description\0\u{1}RecordType\0\u{1}Shared\0\u{1}Parents\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.mutable) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.inUse) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastUsedAt) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.usageCount) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.recordType) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.shared) }()
      case 12: try { try decoder.decodeRepeatedStringField(value: &self.parents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.mutable != false {
      try visitor.visitSingularBoolField(value: self.mutable, fieldNumber: 2)
    }
    if self.inUse != false {
      try visitor.visitSingularBoolField(value: self.inUse, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 4)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 5)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lastUsedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.usageCount != 0 {
      try visitor.visitSingularInt64Field(value: self.usageCount, fieldNumber: 8)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 9)
    }
    if !self.recordType.isEmpty {
      try visitor.visitSingularStringField(value: self.recordType, fieldNumber: 10)
    }
    if self.shared != false {
      try visitor.visitSingularBoolField(value: self.shared, fieldNumber: 11)
    }
    if !self.parents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parents, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_UsageRecord, rhs: Moby_Buildkit_V1_UsageRecord) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.mutable != rhs.mutable {return false}
    if lhs.inUse != rhs.inUse {return false}
    if lhs.size != rhs.size {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._lastUsedAt != rhs._lastUsedAt {return false}
    if lhs.usageCount != rhs.usageCount {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.recordType != rhs.recordType {return false}
    if lhs.shared != rhs.shared {return false}
    if lhs.parents != rhs.parents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_SolveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SolveRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Ref\0\u{1}Definition\0\u{1}ExporterDeprecated\0\u{1}ExporterAttrsDeprecated\0\u{1}Session\0\u{1}Frontend\0\u{1}FrontendAttrs\0\u{1}Cache\0\u{1}Entitlements\0\u{1}FrontendInputs\0\u{1}Internal\0\u{1}SourcePolicy\0\u{1}Exporters\0\u{1}EnableSessionExporter\0")

  fileprivate class _StorageClass {
    var _ref: String = String()
    var _definition: Pb_Definition? = nil
    var _exporterDeprecated: String = String()
    var _exporterAttrsDeprecated: Dictionary<String,String> = [:]
    var _session: String = String()
    var _frontend: String = String()
    var _frontendAttrs: Dictionary<String,String> = [:]
    var _cache: Moby_Buildkit_V1_CacheOptions? = nil
    var _entitlements: [String] = []
    var _frontendInputs: Dictionary<String,Pb_Definition> = [:]
    var _internal: Bool = false
    var _sourcePolicy: Moby_Buildkit_V1_Sourcepolicy_Policy? = nil
    var _exporters: [Moby_Buildkit_V1_Exporter] = []
    var _enableSessionExporter: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ref = source._ref
      _definition = source._definition
      _exporterDeprecated = source._exporterDeprecated
      _exporterAttrsDeprecated = source._exporterAttrsDeprecated
      _session = source._session
      _frontend = source._frontend
      _frontendAttrs = source._frontendAttrs
      _cache = source._cache
      _entitlements = source._entitlements
      _frontendInputs = source._frontendInputs
      _internal = source._internal
      _sourcePolicy = source._sourcePolicy
      _exporters = source._exporters
      _enableSessionExporter = source._enableSessionExporter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._ref) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._definition) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._exporterDeprecated) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._exporterAttrsDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._session) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._frontend) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._frontendAttrs) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._cache) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._entitlements) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_Definition>.self, value: &_storage._frontendInputs) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._internal) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._sourcePolicy) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._exporters) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._enableSessionExporter) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._ref.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ref, fieldNumber: 1)
      }
      try { if let v = _storage._definition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._exporterDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exporterDeprecated, fieldNumber: 3)
      }
      if !_storage._exporterAttrsDeprecated.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._exporterAttrsDeprecated, fieldNumber: 4)
      }
      if !_storage._session.isEmpty {
        try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 5)
      }
      if !_storage._frontend.isEmpty {
        try visitor.visitSingularStringField(value: _storage._frontend, fieldNumber: 6)
      }
      if !_storage._frontendAttrs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._frontendAttrs, fieldNumber: 7)
      }
      try { if let v = _storage._cache {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._entitlements.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._entitlements, fieldNumber: 9)
      }
      if !_storage._frontendInputs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_Definition>.self, value: _storage._frontendInputs, fieldNumber: 10)
      }
      if _storage._internal != false {
        try visitor.visitSingularBoolField(value: _storage._internal, fieldNumber: 11)
      }
      try { if let v = _storage._sourcePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._exporters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._exporters, fieldNumber: 13)
      }
      if _storage._enableSessionExporter != false {
        try visitor.visitSingularBoolField(value: _storage._enableSessionExporter, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_SolveRequest, rhs: Moby_Buildkit_V1_SolveRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ref != rhs_storage._ref {return false}
        if _storage._definition != rhs_storage._definition {return false}
        if _storage._exporterDeprecated != rhs_storage._exporterDeprecated {return false}
        if _storage._exporterAttrsDeprecated != rhs_storage._exporterAttrsDeprecated {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._frontend != rhs_storage._frontend {return false}
        if _storage._frontendAttrs != rhs_storage._frontendAttrs {return false}
        if _storage._cache != rhs_storage._cache {return false}
        if _storage._entitlements != rhs_storage._entitlements {return false}
        if _storage._frontendInputs != rhs_storage._frontendInputs {return false}
        if _storage._internal != rhs_storage._internal {return false}
        if _storage._sourcePolicy != rhs_storage._sourcePolicy {return false}
        if _storage._exporters != rhs_storage._exporters {return false}
        if _storage._enableSessionExporter != rhs_storage._enableSessionExporter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_CacheOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CacheOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ExportRefDeprecated\0\u{1}ImportRefsDeprecated\0\u{1}ExportAttrsDeprecated\0\u{1}Exports\0\u{1}Imports\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exportRefDeprecated) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.importRefsDeprecated) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.exportAttrsDeprecated) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.exports) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.imports) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exportRefDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.exportRefDeprecated, fieldNumber: 1)
    }
    if !self.importRefsDeprecated.isEmpty {
      try visitor.visitRepeatedStringField(value: self.importRefsDeprecated, fieldNumber: 2)
    }
    if !self.exportAttrsDeprecated.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.exportAttrsDeprecated, fieldNumber: 3)
    }
    if !self.exports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exports, fieldNumber: 4)
    }
    if !self.imports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.imports, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_CacheOptions, rhs: Moby_Buildkit_V1_CacheOptions) -> Bool {
    if lhs.exportRefDeprecated != rhs.exportRefDeprecated {return false}
    if lhs.importRefsDeprecated != rhs.importRefsDeprecated {return false}
    if lhs.exportAttrsDeprecated != rhs.exportAttrsDeprecated {return false}
    if lhs.exports != rhs.exports {return false}
    if lhs.imports != rhs.imports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_CacheOptionsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CacheOptionsEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Type\0\u{1}Attrs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attrs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.attrs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attrs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_CacheOptionsEntry, rhs: Moby_Buildkit_V1_CacheOptionsEntry) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.attrs != rhs.attrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_SolveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SolveResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ExporterResponse\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.exporterResponse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exporterResponse.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.exporterResponse, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_SolveResponse, rhs: Moby_Buildkit_V1_SolveResponse) -> Bool {
    if lhs.exporterResponse != rhs.exporterResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Ref\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ref) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ref.isEmpty {
      try visitor.visitSingularStringField(value: self.ref, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_StatusRequest, rhs: Moby_Buildkit_V1_StatusRequest) -> Bool {
    if lhs.ref != rhs.ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vertexes\0\u{1}statuses\0\u{1}logs\0\u{1}warnings\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vertexes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.statuses) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.logs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.warnings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vertexes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vertexes, fieldNumber: 1)
    }
    if !self.statuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statuses, fieldNumber: 2)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 3)
    }
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.warnings, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_StatusResponse, rhs: Moby_Buildkit_V1_StatusResponse) -> Bool {
    if lhs.vertexes != rhs.vertexes {return false}
    if lhs.statuses != rhs.statuses {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_Vertex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vertex"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}digest\0\u{1}inputs\0\u{1}name\0\u{1}cached\0\u{1}started\0\u{1}completed\0\u{1}error\0\u{1}progressGroup\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.digest) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.inputs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.cached) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._started) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._completed) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._progressGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.digest.isEmpty {
      try visitor.visitSingularStringField(value: self.digest, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputs, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.cached != false {
      try visitor.visitSingularBoolField(value: self.cached, fieldNumber: 4)
    }
    try { if let v = self._started {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._completed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 7)
    }
    try { if let v = self._progressGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_Vertex, rhs: Moby_Buildkit_V1_Vertex) -> Bool {
    if lhs.digest != rhs.digest {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.name != rhs.name {return false}
    if lhs.cached != rhs.cached {return false}
    if lhs._started != rhs._started {return false}
    if lhs._completed != rhs._completed {return false}
    if lhs.error != rhs.error {return false}
    if lhs._progressGroup != rhs._progressGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_VertexStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VertexStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}vertex\0\u{1}name\0\u{1}current\0\u{1}total\0\u{1}timestamp\0\u{1}started\0\u{1}completed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.vertex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.current) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._started) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._completed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.vertex.isEmpty {
      try visitor.visitSingularStringField(value: self.vertex, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.current != 0 {
      try visitor.visitSingularInt64Field(value: self.current, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 5)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._started {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._completed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_VertexStatus, rhs: Moby_Buildkit_V1_VertexStatus) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.vertex != rhs.vertex {return false}
    if lhs.name != rhs.name {return false}
    if lhs.current != rhs.current {return false}
    if lhs.total != rhs.total {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._started != rhs._started {return false}
    if lhs._completed != rhs._completed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_VertexLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VertexLog"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vertex\0\u{1}timestamp\0\u{1}stream\0\u{1}msg\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vertex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.stream) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.vertex.isEmpty {
      try visitor.visitSingularStringField(value: self.vertex, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.stream != 0 {
      try visitor.visitSingularInt64Field(value: self.stream, fieldNumber: 3)
    }
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_VertexLog, rhs: Moby_Buildkit_V1_VertexLog) -> Bool {
    if lhs.vertex != rhs.vertex {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.stream != rhs.stream {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_VertexWarning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VertexWarning"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vertex\0\u{1}level\0\u{1}short\0\u{1}detail\0\u{1}url\0\u{1}info\0\u{1}ranges\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vertex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.level) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.short) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.detail) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.vertex.isEmpty {
      try visitor.visitSingularStringField(value: self.vertex, fieldNumber: 1)
    }
    if self.level != 0 {
      try visitor.visitSingularInt64Field(value: self.level, fieldNumber: 2)
    }
    if !self.short.isEmpty {
      try visitor.visitSingularBytesField(value: self.short, fieldNumber: 3)
    }
    if !self.detail.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.detail, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_VertexWarning, rhs: Moby_Buildkit_V1_VertexWarning) -> Bool {
    if lhs.vertex != rhs.vertex {return false}
    if lhs.level != rhs.level {return false}
    if lhs.short != rhs.short {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.url != rhs.url {return false}
    if lhs._info != rhs._info {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_BytesMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BytesMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_BytesMessage, rhs: Moby_Buildkit_V1_BytesMessage) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_ListWorkersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_ListWorkersRequest, rhs: Moby_Buildkit_V1_ListWorkersRequest) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_ListWorkersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}record\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.record) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.record.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.record, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_ListWorkersResponse, rhs: Moby_Buildkit_V1_ListWorkersResponse) -> Bool {
    if lhs.record != rhs.record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_InfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_InfoRequest, rhs: Moby_Buildkit_V1_InfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_InfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}buildkitVersion\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._buildkitVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._buildkitVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_InfoResponse, rhs: Moby_Buildkit_V1_InfoResponse) -> Bool {
    if lhs._buildkitVersion != rhs._buildkitVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_BuildHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildHistoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ActiveOnly\0\u{1}Ref\0\u{1}EarlyExit\0\u{1}Filter\0\u{1}Limit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.activeOnly) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ref) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.earlyExit) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeOnly != false {
      try visitor.visitSingularBoolField(value: self.activeOnly, fieldNumber: 1)
    }
    if !self.ref.isEmpty {
      try visitor.visitSingularStringField(value: self.ref, fieldNumber: 2)
    }
    if self.earlyExit != false {
      try visitor.visitSingularBoolField(value: self.earlyExit, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filter, fieldNumber: 4)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_BuildHistoryRequest, rhs: Moby_Buildkit_V1_BuildHistoryRequest) -> Bool {
    if lhs.activeOnly != rhs.activeOnly {return false}
    if lhs.ref != rhs.ref {return false}
    if lhs.earlyExit != rhs.earlyExit {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_BuildHistoryEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildHistoryEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}record\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._record) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .started {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._record {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_BuildHistoryEvent, rhs: Moby_Buildkit_V1_BuildHistoryEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._record != rhs._record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_BuildHistoryRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildHistoryRecord"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Ref\0\u{1}Frontend\0\u{1}FrontendAttrs\0\u{1}Exporters\0\u{1}error\0\u{1}CreatedAt\0\u{1}CompletedAt\0\u{1}logs\0\u{1}ExporterResponse\0\u{1}Result\0\u{1}Results\0\u{1}Generation\0\u{1}trace\0\u{1}pinned\0\u{1}numCachedSteps\0\u{1}numTotalSteps\0\u{1}numCompletedSteps\0\u{1}externalError\0\u{1}numWarnings\0")

  fileprivate class _StorageClass {
    var _ref: String = String()
    var _frontend: String = String()
    var _frontendAttrs: Dictionary<String,String> = [:]
    var _exporters: [Moby_Buildkit_V1_Exporter] = []
    var _error: Google_Rpc_Status? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _completedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _logs: Moby_Buildkit_V1_Descriptor? = nil
    var _exporterResponse: Dictionary<String,String> = [:]
    var _result: Moby_Buildkit_V1_BuildResultInfo? = nil
    var _results: Dictionary<String,Moby_Buildkit_V1_BuildResultInfo> = [:]
    var _generation: Int32 = 0
    var _trace: Moby_Buildkit_V1_Descriptor? = nil
    var _pinned: Bool = false
    var _numCachedSteps: Int32 = 0
    var _numTotalSteps: Int32 = 0
    var _numCompletedSteps: Int32 = 0
    var _externalError: Moby_Buildkit_V1_Descriptor? = nil
    var _numWarnings: Int32 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ref = source._ref
      _frontend = source._frontend
      _frontendAttrs = source._frontendAttrs
      _exporters = source._exporters
      _error = source._error
      _createdAt = source._createdAt
      _completedAt = source._completedAt
      _logs = source._logs
      _exporterResponse = source._exporterResponse
      _result = source._result
      _results = source._results
      _generation = source._generation
      _trace = source._trace
      _pinned = source._pinned
      _numCachedSteps = source._numCachedSteps
      _numTotalSteps = source._numTotalSteps
      _numCompletedSteps = source._numCompletedSteps
      _externalError = source._externalError
      _numWarnings = source._numWarnings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._ref) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._frontend) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._frontendAttrs) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._exporters) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._completedAt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._logs) }()
        case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._exporterResponse) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Moby_Buildkit_V1_BuildResultInfo>.self, value: &_storage._results) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._generation) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._trace) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._pinned) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._numCachedSteps) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._numTotalSteps) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._numCompletedSteps) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._externalError) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._numWarnings) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._ref.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ref, fieldNumber: 1)
      }
      if !_storage._frontend.isEmpty {
        try visitor.visitSingularStringField(value: _storage._frontend, fieldNumber: 2)
      }
      if !_storage._frontendAttrs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._frontendAttrs, fieldNumber: 3)
      }
      if !_storage._exporters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._exporters, fieldNumber: 4)
      }
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._completedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._logs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._exporterResponse.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._exporterResponse, fieldNumber: 9)
      }
      try { if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._results.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Moby_Buildkit_V1_BuildResultInfo>.self, value: _storage._results, fieldNumber: 11)
      }
      if _storage._generation != 0 {
        try visitor.visitSingularInt32Field(value: _storage._generation, fieldNumber: 12)
      }
      try { if let v = _storage._trace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._pinned != false {
        try visitor.visitSingularBoolField(value: _storage._pinned, fieldNumber: 14)
      }
      if _storage._numCachedSteps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numCachedSteps, fieldNumber: 15)
      }
      if _storage._numTotalSteps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numTotalSteps, fieldNumber: 16)
      }
      if _storage._numCompletedSteps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numCompletedSteps, fieldNumber: 17)
      }
      try { if let v = _storage._externalError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._numWarnings != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numWarnings, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_BuildHistoryRecord, rhs: Moby_Buildkit_V1_BuildHistoryRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ref != rhs_storage._ref {return false}
        if _storage._frontend != rhs_storage._frontend {return false}
        if _storage._frontendAttrs != rhs_storage._frontendAttrs {return false}
        if _storage._exporters != rhs_storage._exporters {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._completedAt != rhs_storage._completedAt {return false}
        if _storage._logs != rhs_storage._logs {return false}
        if _storage._exporterResponse != rhs_storage._exporterResponse {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._results != rhs_storage._results {return false}
        if _storage._generation != rhs_storage._generation {return false}
        if _storage._trace != rhs_storage._trace {return false}
        if _storage._pinned != rhs_storage._pinned {return false}
        if _storage._numCachedSteps != rhs_storage._numCachedSteps {return false}
        if _storage._numTotalSteps != rhs_storage._numTotalSteps {return false}
        if _storage._numCompletedSteps != rhs_storage._numCompletedSteps {return false}
        if _storage._externalError != rhs_storage._externalError {return false}
        if _storage._numWarnings != rhs_storage._numWarnings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_UpdateBuildHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateBuildHistoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Ref\0\u{1}Pinned\0\u{1}Delete\0\u{1}Finalize\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ref) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.pinned) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.delete) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.finalize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ref.isEmpty {
      try visitor.visitSingularStringField(value: self.ref, fieldNumber: 1)
    }
    if self.pinned != false {
      try visitor.visitSingularBoolField(value: self.pinned, fieldNumber: 2)
    }
    if self.delete != false {
      try visitor.visitSingularBoolField(value: self.delete, fieldNumber: 3)
    }
    if self.finalize != false {
      try visitor.visitSingularBoolField(value: self.finalize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_UpdateBuildHistoryRequest, rhs: Moby_Buildkit_V1_UpdateBuildHistoryRequest) -> Bool {
    if lhs.ref != rhs.ref {return false}
    if lhs.pinned != rhs.pinned {return false}
    if lhs.delete != rhs.delete {return false}
    if lhs.finalize != rhs.finalize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_UpdateBuildHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateBuildHistoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_UpdateBuildHistoryResponse, rhs: Moby_Buildkit_V1_UpdateBuildHistoryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_Descriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Descriptor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}media_type\0\u{1}digest\0\u{1}size\0\u{2}\u{2}annotations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.digest) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.annotations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaType.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaType, fieldNumber: 1)
    }
    if !self.digest.isEmpty {
      try visitor.visitSingularStringField(value: self.digest, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 3)
    }
    if !self.annotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.annotations, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_Descriptor, rhs: Moby_Buildkit_V1_Descriptor) -> Bool {
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.digest != rhs.digest {return false}
    if lhs.size != rhs.size {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_BuildResultInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildResultInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ResultDeprecated\0\u{1}Attestations\0\u{1}Results\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resultDeprecated) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attestations) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Moby_Buildkit_V1_Descriptor>.self, value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resultDeprecated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.attestations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attestations, fieldNumber: 2)
    }
    if !self.results.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Moby_Buildkit_V1_Descriptor>.self, value: self.results, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_BuildResultInfo, rhs: Moby_Buildkit_V1_BuildResultInfo) -> Bool {
    if lhs._resultDeprecated != rhs._resultDeprecated {return false}
    if lhs.attestations != rhs.attestations {return false}
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Moby_Buildkit_V1_Exporter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Exporter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Type\0\u{1}Attrs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attrs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.attrs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attrs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Moby_Buildkit_V1_Exporter, rhs: Moby_Buildkit_V1_Exporter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.attrs != rhs.attrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
